/* soapC.cpp
   Generated by gSOAP 2.8.59 for mySap.h

gSOAP XML Web services tools
Copyright (C) 2000-2017, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.59 2019-06-20 03:04:19 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, ""))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap);
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", "");
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)(void*)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap);
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = soap_new_SOAP_ENV__Detail(soap);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)(void*)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if ((soap->error && soap->error != SOAP_TAG_MISMATCH) || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_web__user:
		return soap_in_web__user(soap, NULL, NULL, "web:user");
	case SOAP_TYPE_web__loginResponse:
		return soap_in_web__loginResponse(soap, NULL, NULL, "web:loginResponse");
	case SOAP_TYPE_web__login:
		return soap_in_web__login(soap, NULL, NULL, "web:login");
	case SOAP_TYPE_web__saveVehicleInfoResponse:
		return soap_in_web__saveVehicleInfoResponse(soap, NULL, NULL, "web:saveVehicleInfoResponse");
	case SOAP_TYPE_web__saveVehicleInfo:
		return soap_in_web__saveVehicleInfo(soap, NULL, NULL, "web:saveVehicleInfo");
	case SOAP_TYPE_web__savePoundInfoResponse:
		return soap_in_web__savePoundInfoResponse(soap, NULL, NULL, "web:savePoundInfoResponse");
	case SOAP_TYPE_web__poundInfo:
		return soap_in_web__poundInfo(soap, NULL, NULL, "web:poundInfo");
	case SOAP_TYPE_web__savePoundInfo:
		return soap_in_web__savePoundInfo(soap, NULL, NULL, "web:savePoundInfo");
	case SOAP_TYPE_web__saveGrainUserResponse:
		return soap_in_web__saveGrainUserResponse(soap, NULL, NULL, "web:saveGrainUserResponse");
	case SOAP_TYPE_web__saveGrainUser:
		return soap_in_web__saveGrainUser(soap, NULL, NULL, "web:saveGrainUser");
	case SOAP_TYPE_web__saveCheckingInfoResponse:
		return soap_in_web__saveCheckingInfoResponse(soap, NULL, NULL, "web:saveCheckingInfoResponse");
	case SOAP_TYPE_web__checkingInfo:
		return soap_in_web__checkingInfo(soap, NULL, NULL, "web:checkingInfo");
	case SOAP_TYPE_web__saveCheckingInfo:
		return soap_in_web__saveCheckingInfo(soap, NULL, NULL, "web:saveCheckingInfo");
	case SOAP_TYPE_web__savePoundInfoAResponse:
		return soap_in_web__savePoundInfoAResponse(soap, NULL, NULL, "web:savePoundInfoAResponse");
	case SOAP_TYPE_web__savePoundInfoA:
		return soap_in_web__savePoundInfoA(soap, NULL, NULL, "web:savePoundInfoA");
	case SOAP_TYPE_web__updatePasswordResponse:
		return soap_in_web__updatePasswordResponse(soap, NULL, NULL, "web:updatePasswordResponse");
	case SOAP_TYPE_web__updatePassword:
		return soap_in_web__updatePassword(soap, NULL, NULL, "web:updatePassword");
	case SOAP_TYPE_web__saveSamplersResponse:
		return soap_in_web__saveSamplersResponse(soap, NULL, NULL, "web:saveSamplersResponse");
	case SOAP_TYPE_web__saveSamplers:
		return soap_in_web__saveSamplers(soap, NULL, NULL, "web:saveSamplers");
	case SOAP_TYPE_web__saveGPOrdersResponse:
		return soap_in_web__saveGPOrdersResponse(soap, NULL, NULL, "web:saveGPOrdersResponse");
	case SOAP_TYPE_web__gpOrders:
		return soap_in_web__gpOrders(soap, NULL, NULL, "web:gpOrders");
	case SOAP_TYPE_web__saveGPOrders:
		return soap_in_web__saveGPOrders(soap, NULL, NULL, "web:saveGPOrders");
	case SOAP_TYPE_PointerToweb__login:
		return soap_in_PointerToweb__login(soap, NULL, NULL, "web:login");
	case SOAP_TYPE_PointerToweb__saveCheckingInfo:
		return soap_in_PointerToweb__saveCheckingInfo(soap, NULL, NULL, "web:saveCheckingInfo");
	case SOAP_TYPE_PointerToweb__saveSamplers:
		return soap_in_PointerToweb__saveSamplers(soap, NULL, NULL, "web:saveSamplers");
	case SOAP_TYPE_PointerToweb__saveGPOrders:
		return soap_in_PointerToweb__saveGPOrders(soap, NULL, NULL, "web:saveGPOrders");
	case SOAP_TYPE_PointerToweb__savePoundInfo:
		return soap_in_PointerToweb__savePoundInfo(soap, NULL, NULL, "web:savePoundInfo");
	case SOAP_TYPE_PointerToweb__savePoundInfoA:
		return soap_in_PointerToweb__savePoundInfoA(soap, NULL, NULL, "web:savePoundInfoA");
	case SOAP_TYPE_PointerToweb__saveGrainUser:
		return soap_in_PointerToweb__saveGrainUser(soap, NULL, NULL, "web:saveGrainUser");
	case SOAP_TYPE_PointerToweb__saveVehicleInfo:
		return soap_in_PointerToweb__saveVehicleInfo(soap, NULL, NULL, "web:saveVehicleInfo");
	case SOAP_TYPE_PointerToweb__updatePassword:
		return soap_in_PointerToweb__updatePassword(soap, NULL, NULL, "web:updatePassword");
	case SOAP_TYPE_PointerToweb__user:
		return soap_in_PointerToweb__user(soap, NULL, NULL, "web:user");
	case SOAP_TYPE_PointerToweb__poundInfo:
		return soap_in_PointerToweb__poundInfo(soap, NULL, NULL, "web:poundInfo");
	case SOAP_TYPE_PointerToweb__checkingInfo:
		return soap_in_PointerToweb__checkingInfo(soap, NULL, NULL, "web:checkingInfo");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerToweb__gpOrders:
		return soap_in_PointerToweb__gpOrders(soap, NULL, NULL, "web:gpOrders");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "web:user"))
		{	*type = SOAP_TYPE_web__user;
			return soap_in_web__user(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "web:loginResponse"))
		{	*type = SOAP_TYPE_web__loginResponse;
			return soap_in_web__loginResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "web:login"))
		{	*type = SOAP_TYPE_web__login;
			return soap_in_web__login(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "web:saveVehicleInfoResponse"))
		{	*type = SOAP_TYPE_web__saveVehicleInfoResponse;
			return soap_in_web__saveVehicleInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "web:saveVehicleInfo"))
		{	*type = SOAP_TYPE_web__saveVehicleInfo;
			return soap_in_web__saveVehicleInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "web:savePoundInfoResponse"))
		{	*type = SOAP_TYPE_web__savePoundInfoResponse;
			return soap_in_web__savePoundInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "web:poundInfo"))
		{	*type = SOAP_TYPE_web__poundInfo;
			return soap_in_web__poundInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "web:savePoundInfo"))
		{	*type = SOAP_TYPE_web__savePoundInfo;
			return soap_in_web__savePoundInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "web:saveGrainUserResponse"))
		{	*type = SOAP_TYPE_web__saveGrainUserResponse;
			return soap_in_web__saveGrainUserResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "web:saveGrainUser"))
		{	*type = SOAP_TYPE_web__saveGrainUser;
			return soap_in_web__saveGrainUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "web:saveCheckingInfoResponse"))
		{	*type = SOAP_TYPE_web__saveCheckingInfoResponse;
			return soap_in_web__saveCheckingInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "web:checkingInfo"))
		{	*type = SOAP_TYPE_web__checkingInfo;
			return soap_in_web__checkingInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "web:saveCheckingInfo"))
		{	*type = SOAP_TYPE_web__saveCheckingInfo;
			return soap_in_web__saveCheckingInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "web:savePoundInfoAResponse"))
		{	*type = SOAP_TYPE_web__savePoundInfoAResponse;
			return soap_in_web__savePoundInfoAResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "web:savePoundInfoA"))
		{	*type = SOAP_TYPE_web__savePoundInfoA;
			return soap_in_web__savePoundInfoA(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "web:updatePasswordResponse"))
		{	*type = SOAP_TYPE_web__updatePasswordResponse;
			return soap_in_web__updatePasswordResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "web:updatePassword"))
		{	*type = SOAP_TYPE_web__updatePassword;
			return soap_in_web__updatePassword(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "web:saveSamplersResponse"))
		{	*type = SOAP_TYPE_web__saveSamplersResponse;
			return soap_in_web__saveSamplersResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "web:saveSamplers"))
		{	*type = SOAP_TYPE_web__saveSamplers;
			return soap_in_web__saveSamplers(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "web:saveGPOrdersResponse"))
		{	*type = SOAP_TYPE_web__saveGPOrdersResponse;
			return soap_in_web__saveGPOrdersResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "web:gpOrders"))
		{	*type = SOAP_TYPE_web__gpOrders;
			return soap_in_web__gpOrders(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "web:saveGPOrders"))
		{	*type = SOAP_TYPE_web__saveGPOrders;
			return soap_in_web__saveGPOrders(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level = %u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other && !soap->fignore)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && !soap->fignore && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body && soap_ignore(soap))
				return soap->error;
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, SOAP_MULTIREFTAG, pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_web__user:
		return ((web__user *)ptr)->soap_out(soap, tag, id, "web:user");
	case SOAP_TYPE_web__loginResponse:
		return ((web__loginResponse *)ptr)->soap_out(soap, tag, id, "web:loginResponse");
	case SOAP_TYPE_web__login:
		return ((web__login *)ptr)->soap_out(soap, tag, id, "web:login");
	case SOAP_TYPE_web__saveVehicleInfoResponse:
		return ((web__saveVehicleInfoResponse *)ptr)->soap_out(soap, tag, id, "web:saveVehicleInfoResponse");
	case SOAP_TYPE_web__saveVehicleInfo:
		return ((web__saveVehicleInfo *)ptr)->soap_out(soap, tag, id, "web:saveVehicleInfo");
	case SOAP_TYPE_web__savePoundInfoResponse:
		return ((web__savePoundInfoResponse *)ptr)->soap_out(soap, tag, id, "web:savePoundInfoResponse");
	case SOAP_TYPE_web__poundInfo:
		return ((web__poundInfo *)ptr)->soap_out(soap, tag, id, "web:poundInfo");
	case SOAP_TYPE_web__savePoundInfo:
		return ((web__savePoundInfo *)ptr)->soap_out(soap, tag, id, "web:savePoundInfo");
	case SOAP_TYPE_web__saveGrainUserResponse:
		return ((web__saveGrainUserResponse *)ptr)->soap_out(soap, tag, id, "web:saveGrainUserResponse");
	case SOAP_TYPE_web__saveGrainUser:
		return ((web__saveGrainUser *)ptr)->soap_out(soap, tag, id, "web:saveGrainUser");
	case SOAP_TYPE_web__saveCheckingInfoResponse:
		return ((web__saveCheckingInfoResponse *)ptr)->soap_out(soap, tag, id, "web:saveCheckingInfoResponse");
	case SOAP_TYPE_web__checkingInfo:
		return ((web__checkingInfo *)ptr)->soap_out(soap, tag, id, "web:checkingInfo");
	case SOAP_TYPE_web__saveCheckingInfo:
		return ((web__saveCheckingInfo *)ptr)->soap_out(soap, tag, id, "web:saveCheckingInfo");
	case SOAP_TYPE_web__savePoundInfoAResponse:
		return ((web__savePoundInfoAResponse *)ptr)->soap_out(soap, tag, id, "web:savePoundInfoAResponse");
	case SOAP_TYPE_web__savePoundInfoA:
		return ((web__savePoundInfoA *)ptr)->soap_out(soap, tag, id, "web:savePoundInfoA");
	case SOAP_TYPE_web__updatePasswordResponse:
		return ((web__updatePasswordResponse *)ptr)->soap_out(soap, tag, id, "web:updatePasswordResponse");
	case SOAP_TYPE_web__updatePassword:
		return ((web__updatePassword *)ptr)->soap_out(soap, tag, id, "web:updatePassword");
	case SOAP_TYPE_web__saveSamplersResponse:
		return ((web__saveSamplersResponse *)ptr)->soap_out(soap, tag, id, "web:saveSamplersResponse");
	case SOAP_TYPE_web__saveSamplers:
		return ((web__saveSamplers *)ptr)->soap_out(soap, tag, id, "web:saveSamplers");
	case SOAP_TYPE_web__saveGPOrdersResponse:
		return ((web__saveGPOrdersResponse *)ptr)->soap_out(soap, tag, id, "web:saveGPOrdersResponse");
	case SOAP_TYPE_web__gpOrders:
		return ((web__gpOrders *)ptr)->soap_out(soap, tag, id, "web:gpOrders");
	case SOAP_TYPE_web__saveGPOrders:
		return ((web__saveGPOrders *)ptr)->soap_out(soap, tag, id, "web:saveGPOrders");
	case SOAP_TYPE_PointerToweb__login:
		return soap_out_PointerToweb__login(soap, tag, id, (web__login *const*)ptr, "web:login");
	case SOAP_TYPE_PointerToweb__saveCheckingInfo:
		return soap_out_PointerToweb__saveCheckingInfo(soap, tag, id, (web__saveCheckingInfo *const*)ptr, "web:saveCheckingInfo");
	case SOAP_TYPE_PointerToweb__saveSamplers:
		return soap_out_PointerToweb__saveSamplers(soap, tag, id, (web__saveSamplers *const*)ptr, "web:saveSamplers");
	case SOAP_TYPE_PointerToweb__saveGPOrders:
		return soap_out_PointerToweb__saveGPOrders(soap, tag, id, (web__saveGPOrders *const*)ptr, "web:saveGPOrders");
	case SOAP_TYPE_PointerToweb__savePoundInfo:
		return soap_out_PointerToweb__savePoundInfo(soap, tag, id, (web__savePoundInfo *const*)ptr, "web:savePoundInfo");
	case SOAP_TYPE_PointerToweb__savePoundInfoA:
		return soap_out_PointerToweb__savePoundInfoA(soap, tag, id, (web__savePoundInfoA *const*)ptr, "web:savePoundInfoA");
	case SOAP_TYPE_PointerToweb__saveGrainUser:
		return soap_out_PointerToweb__saveGrainUser(soap, tag, id, (web__saveGrainUser *const*)ptr, "web:saveGrainUser");
	case SOAP_TYPE_PointerToweb__saveVehicleInfo:
		return soap_out_PointerToweb__saveVehicleInfo(soap, tag, id, (web__saveVehicleInfo *const*)ptr, "web:saveVehicleInfo");
	case SOAP_TYPE_PointerToweb__updatePassword:
		return soap_out_PointerToweb__updatePassword(soap, tag, id, (web__updatePassword *const*)ptr, "web:updatePassword");
	case SOAP_TYPE_PointerToweb__user:
		return soap_out_PointerToweb__user(soap, tag, id, (web__user *const*)ptr, "web:user");
	case SOAP_TYPE_PointerToweb__poundInfo:
		return soap_out_PointerToweb__poundInfo(soap, tag, id, (web__poundInfo *const*)ptr, "web:poundInfo");
	case SOAP_TYPE_PointerToweb__checkingInfo:
		return soap_out_PointerToweb__checkingInfo(soap, tag, id, (web__checkingInfo *const*)ptr, "web:checkingInfo");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerToweb__gpOrders:
		return soap_out_PointerToweb__gpOrders(soap, tag, id, (web__gpOrders *const*)ptr, "web:gpOrders");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	case 0:
		return SOAP_OK;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_putelement '%s' failed for type %d in soapC.cpp\n", tag ? tag : "", type));
	return soap_element_empty(soap, tag); /* unknown type to serialize */
}
#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_web__user:
		((web__user *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_web__loginResponse:
		((web__loginResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_web__login:
		((web__login *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_web__saveVehicleInfoResponse:
		((web__saveVehicleInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_web__saveVehicleInfo:
		((web__saveVehicleInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_web__savePoundInfoResponse:
		((web__savePoundInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_web__poundInfo:
		((web__poundInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_web__savePoundInfo:
		((web__savePoundInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_web__saveGrainUserResponse:
		((web__saveGrainUserResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_web__saveGrainUser:
		((web__saveGrainUser *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_web__saveCheckingInfoResponse:
		((web__saveCheckingInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_web__checkingInfo:
		((web__checkingInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_web__saveCheckingInfo:
		((web__saveCheckingInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_web__savePoundInfoAResponse:
		((web__savePoundInfoAResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_web__savePoundInfoA:
		((web__savePoundInfoA *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_web__updatePasswordResponse:
		((web__updatePasswordResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_web__updatePassword:
		((web__updatePassword *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_web__saveSamplersResponse:
		((web__saveSamplersResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_web__saveSamplers:
		((web__saveSamplers *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_web__saveGPOrdersResponse:
		((web__saveGPOrdersResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_web__gpOrders:
		((web__gpOrders *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_web__saveGPOrders:
		((web__saveGPOrders *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___web__login:
		soap_serialize___web__login(soap, (const struct __web__login *)ptr);
		break;
	case SOAP_TYPE___web__saveCheckingInfo:
		soap_serialize___web__saveCheckingInfo(soap, (const struct __web__saveCheckingInfo *)ptr);
		break;
	case SOAP_TYPE___web__saveSamplers:
		soap_serialize___web__saveSamplers(soap, (const struct __web__saveSamplers *)ptr);
		break;
	case SOAP_TYPE___web__saveGPOrders:
		soap_serialize___web__saveGPOrders(soap, (const struct __web__saveGPOrders *)ptr);
		break;
	case SOAP_TYPE___web__savePoundInfo:
		soap_serialize___web__savePoundInfo(soap, (const struct __web__savePoundInfo *)ptr);
		break;
	case SOAP_TYPE___web__savePoundInfoA:
		soap_serialize___web__savePoundInfoA(soap, (const struct __web__savePoundInfoA *)ptr);
		break;
	case SOAP_TYPE___web__saveGrainUser:
		soap_serialize___web__saveGrainUser(soap, (const struct __web__saveGrainUser *)ptr);
		break;
	case SOAP_TYPE___web__saveVehicleInfo:
		soap_serialize___web__saveVehicleInfo(soap, (const struct __web__saveVehicleInfo *)ptr);
		break;
	case SOAP_TYPE___web__updatePassword:
		soap_serialize___web__updatePassword(soap, (const struct __web__updatePassword *)ptr);
		break;
	case SOAP_TYPE_PointerToweb__login:
		soap_serialize_PointerToweb__login(soap, (web__login *const*)ptr);
		break;
	case SOAP_TYPE_PointerToweb__saveCheckingInfo:
		soap_serialize_PointerToweb__saveCheckingInfo(soap, (web__saveCheckingInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToweb__saveSamplers:
		soap_serialize_PointerToweb__saveSamplers(soap, (web__saveSamplers *const*)ptr);
		break;
	case SOAP_TYPE_PointerToweb__saveGPOrders:
		soap_serialize_PointerToweb__saveGPOrders(soap, (web__saveGPOrders *const*)ptr);
		break;
	case SOAP_TYPE_PointerToweb__savePoundInfo:
		soap_serialize_PointerToweb__savePoundInfo(soap, (web__savePoundInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToweb__savePoundInfoA:
		soap_serialize_PointerToweb__savePoundInfoA(soap, (web__savePoundInfoA *const*)ptr);
		break;
	case SOAP_TYPE_PointerToweb__saveGrainUser:
		soap_serialize_PointerToweb__saveGrainUser(soap, (web__saveGrainUser *const*)ptr);
		break;
	case SOAP_TYPE_PointerToweb__saveVehicleInfo:
		soap_serialize_PointerToweb__saveVehicleInfo(soap, (web__saveVehicleInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToweb__updatePassword:
		soap_serialize_PointerToweb__updatePassword(soap, (web__updatePassword *const*)ptr);
		break;
	case SOAP_TYPE_PointerToweb__user:
		soap_serialize_PointerToweb__user(soap, (web__user *const*)ptr);
		break;
	case SOAP_TYPE_PointerToweb__poundInfo:
		soap_serialize_PointerToweb__poundInfo(soap, (web__poundInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToweb__checkingInfo:
		soap_serialize_PointerToweb__checkingInfo(soap, (web__checkingInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerToweb__gpOrders:
		soap_serialize_PointerToweb__gpOrders(soap, (web__gpOrders *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	}
}
#ifdef __cplusplus
}
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_dupelement(struct soap *soap, const void *ptr, int type)
{(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	return NULL;
}
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_delelement(const void *ptr, int type)
{(void)ptr; (void)type; /* appease -Wall -Werror */
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_web__saveGPOrders:
		return (void*)soap_instantiate_web__saveGPOrders(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_web__gpOrders:
		return (void*)soap_instantiate_web__gpOrders(soap, -1, type, arrayType, n);
	case SOAP_TYPE_web__saveGPOrdersResponse:
		return (void*)soap_instantiate_web__saveGPOrdersResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_web__saveSamplers:
		return (void*)soap_instantiate_web__saveSamplers(soap, -1, type, arrayType, n);
	case SOAP_TYPE_web__saveSamplersResponse:
		return (void*)soap_instantiate_web__saveSamplersResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_web__updatePassword:
		return (void*)soap_instantiate_web__updatePassword(soap, -1, type, arrayType, n);
	case SOAP_TYPE_web__updatePasswordResponse:
		return (void*)soap_instantiate_web__updatePasswordResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_web__savePoundInfoA:
		return (void*)soap_instantiate_web__savePoundInfoA(soap, -1, type, arrayType, n);
	case SOAP_TYPE_web__savePoundInfoAResponse:
		return (void*)soap_instantiate_web__savePoundInfoAResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_web__saveCheckingInfo:
		return (void*)soap_instantiate_web__saveCheckingInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_web__checkingInfo:
		return (void*)soap_instantiate_web__checkingInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_web__saveCheckingInfoResponse:
		return (void*)soap_instantiate_web__saveCheckingInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_web__saveGrainUser:
		return (void*)soap_instantiate_web__saveGrainUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE_web__saveGrainUserResponse:
		return (void*)soap_instantiate_web__saveGrainUserResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_web__savePoundInfo:
		return (void*)soap_instantiate_web__savePoundInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_web__poundInfo:
		return (void*)soap_instantiate_web__poundInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_web__savePoundInfoResponse:
		return (void*)soap_instantiate_web__savePoundInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_web__saveVehicleInfo:
		return (void*)soap_instantiate_web__saveVehicleInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_web__saveVehicleInfoResponse:
		return (void*)soap_instantiate_web__saveVehicleInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_web__login:
		return (void*)soap_instantiate_web__login(soap, -1, type, arrayType, n);
	case SOAP_TYPE_web__loginResponse:
		return (void*)soap_instantiate_web__loginResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_web__user:
		return (void*)soap_instantiate_web__user(soap, -1, type, arrayType, n);
	case SOAP_TYPE___web__updatePassword:
		return (void*)soap_instantiate___web__updatePassword(soap, -1, type, arrayType, n);
	case SOAP_TYPE___web__saveVehicleInfo:
		return (void*)soap_instantiate___web__saveVehicleInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___web__saveGrainUser:
		return (void*)soap_instantiate___web__saveGrainUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE___web__savePoundInfoA:
		return (void*)soap_instantiate___web__savePoundInfoA(soap, -1, type, arrayType, n);
	case SOAP_TYPE___web__savePoundInfo:
		return (void*)soap_instantiate___web__savePoundInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___web__saveGPOrders:
		return (void*)soap_instantiate___web__saveGPOrders(soap, -1, type, arrayType, n);
	case SOAP_TYPE___web__saveSamplers:
		return (void*)soap_instantiate___web__saveSamplers(soap, -1, type, arrayType, n);
	case SOAP_TYPE___web__saveCheckingInfo:
		return (void*)soap_instantiate___web__saveCheckingInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___web__login:
		return (void*)soap_instantiate___web__login(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap *soap, struct soap_clist *p)
{	(void)soap; /* appease -Wall -Werror */
	if (!p->ptr)
		return SOAP_OK;
	switch (p->type)
	{
	case SOAP_TYPE_web__saveGPOrders:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<web__saveGPOrders*>(p->ptr), web__saveGPOrders);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<web__saveGPOrders*>(p->ptr), web__saveGPOrders);
		break;
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_web__gpOrders:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<web__gpOrders*>(p->ptr), web__gpOrders);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<web__gpOrders*>(p->ptr), web__gpOrders);
		break;
	case SOAP_TYPE_web__saveGPOrdersResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<web__saveGPOrdersResponse*>(p->ptr), web__saveGPOrdersResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<web__saveGPOrdersResponse*>(p->ptr), web__saveGPOrdersResponse);
		break;
	case SOAP_TYPE_web__saveSamplers:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<web__saveSamplers*>(p->ptr), web__saveSamplers);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<web__saveSamplers*>(p->ptr), web__saveSamplers);
		break;
	case SOAP_TYPE_web__saveSamplersResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<web__saveSamplersResponse*>(p->ptr), web__saveSamplersResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<web__saveSamplersResponse*>(p->ptr), web__saveSamplersResponse);
		break;
	case SOAP_TYPE_web__updatePassword:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<web__updatePassword*>(p->ptr), web__updatePassword);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<web__updatePassword*>(p->ptr), web__updatePassword);
		break;
	case SOAP_TYPE_web__updatePasswordResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<web__updatePasswordResponse*>(p->ptr), web__updatePasswordResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<web__updatePasswordResponse*>(p->ptr), web__updatePasswordResponse);
		break;
	case SOAP_TYPE_web__savePoundInfoA:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<web__savePoundInfoA*>(p->ptr), web__savePoundInfoA);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<web__savePoundInfoA*>(p->ptr), web__savePoundInfoA);
		break;
	case SOAP_TYPE_web__savePoundInfoAResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<web__savePoundInfoAResponse*>(p->ptr), web__savePoundInfoAResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<web__savePoundInfoAResponse*>(p->ptr), web__savePoundInfoAResponse);
		break;
	case SOAP_TYPE_web__saveCheckingInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<web__saveCheckingInfo*>(p->ptr), web__saveCheckingInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<web__saveCheckingInfo*>(p->ptr), web__saveCheckingInfo);
		break;
	case SOAP_TYPE_web__checkingInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<web__checkingInfo*>(p->ptr), web__checkingInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<web__checkingInfo*>(p->ptr), web__checkingInfo);
		break;
	case SOAP_TYPE_web__saveCheckingInfoResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<web__saveCheckingInfoResponse*>(p->ptr), web__saveCheckingInfoResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<web__saveCheckingInfoResponse*>(p->ptr), web__saveCheckingInfoResponse);
		break;
	case SOAP_TYPE_web__saveGrainUser:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<web__saveGrainUser*>(p->ptr), web__saveGrainUser);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<web__saveGrainUser*>(p->ptr), web__saveGrainUser);
		break;
	case SOAP_TYPE_web__saveGrainUserResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<web__saveGrainUserResponse*>(p->ptr), web__saveGrainUserResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<web__saveGrainUserResponse*>(p->ptr), web__saveGrainUserResponse);
		break;
	case SOAP_TYPE_web__savePoundInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<web__savePoundInfo*>(p->ptr), web__savePoundInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<web__savePoundInfo*>(p->ptr), web__savePoundInfo);
		break;
	case SOAP_TYPE_web__poundInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<web__poundInfo*>(p->ptr), web__poundInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<web__poundInfo*>(p->ptr), web__poundInfo);
		break;
	case SOAP_TYPE_web__savePoundInfoResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<web__savePoundInfoResponse*>(p->ptr), web__savePoundInfoResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<web__savePoundInfoResponse*>(p->ptr), web__savePoundInfoResponse);
		break;
	case SOAP_TYPE_web__saveVehicleInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<web__saveVehicleInfo*>(p->ptr), web__saveVehicleInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<web__saveVehicleInfo*>(p->ptr), web__saveVehicleInfo);
		break;
	case SOAP_TYPE_web__saveVehicleInfoResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<web__saveVehicleInfoResponse*>(p->ptr), web__saveVehicleInfoResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<web__saveVehicleInfoResponse*>(p->ptr), web__saveVehicleInfoResponse);
		break;
	case SOAP_TYPE_web__login:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<web__login*>(p->ptr), web__login);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<web__login*>(p->ptr), web__login);
		break;
	case SOAP_TYPE_web__loginResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<web__loginResponse*>(p->ptr), web__loginResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<web__loginResponse*>(p->ptr), web__loginResponse);
		break;
	case SOAP_TYPE_web__user:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<web__user*>(p->ptr), web__user);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<web__user*>(p->ptr), web__user);
		break;
	case SOAP_TYPE___web__updatePassword:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __web__updatePassword*>(p->ptr), struct __web__updatePassword);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __web__updatePassword*>(p->ptr), struct __web__updatePassword);
		break;
	case SOAP_TYPE___web__saveVehicleInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __web__saveVehicleInfo*>(p->ptr), struct __web__saveVehicleInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __web__saveVehicleInfo*>(p->ptr), struct __web__saveVehicleInfo);
		break;
	case SOAP_TYPE___web__saveGrainUser:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __web__saveGrainUser*>(p->ptr), struct __web__saveGrainUser);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __web__saveGrainUser*>(p->ptr), struct __web__saveGrainUser);
		break;
	case SOAP_TYPE___web__savePoundInfoA:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __web__savePoundInfoA*>(p->ptr), struct __web__savePoundInfoA);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __web__savePoundInfoA*>(p->ptr), struct __web__savePoundInfoA);
		break;
	case SOAP_TYPE___web__savePoundInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __web__savePoundInfo*>(p->ptr), struct __web__savePoundInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __web__savePoundInfo*>(p->ptr), struct __web__savePoundInfo);
		break;
	case SOAP_TYPE___web__saveGPOrders:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __web__saveGPOrders*>(p->ptr), struct __web__saveGPOrders);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __web__saveGPOrders*>(p->ptr), struct __web__saveGPOrders);
		break;
	case SOAP_TYPE___web__saveSamplers:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __web__saveSamplers*>(p->ptr), struct __web__saveSamplers);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __web__saveSamplers*>(p->ptr), struct __web__saveSamplers);
		break;
	case SOAP_TYPE___web__saveCheckingInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __web__saveCheckingInfo*>(p->ptr), struct __web__saveCheckingInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __web__saveCheckingInfo*>(p->ptr), struct __web__saveCheckingInfo);
		break;
	case SOAP_TYPE___web__login:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __web__login*>(p->ptr), struct __web__login);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __web__login*>(p->ptr), struct __web__login);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Header*>(p->ptr), struct SOAP_ENV__Header);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Header*>(p->ptr), struct SOAP_ENV__Header);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Code*>(p->ptr), struct SOAP_ENV__Code);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Code*>(p->ptr), struct SOAP_ENV__Code);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Detail*>(p->ptr), struct SOAP_ENV__Detail);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Detail*>(p->ptr), struct SOAP_ENV__Detail);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Reason*>(p->ptr), struct SOAP_ENV__Reason);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Reason*>(p->ptr), struct SOAP_ENV__Reason);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Fault*>(p->ptr), struct SOAP_ENV__Fault);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Fault*>(p->ptr), struct SOAP_ENV__Fault);
		break;
#endif
	default:
		return SOAP_ERR;
	}
	return SOAP_OK;
}

#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_fbase(int t, int b)
{	(void)t; (void)b; /* appease -Wall -Werror */
	return 0;
}
#ifdef WIN32
#pragma warning(pop)
#endif

#ifndef WITH_NOIDREF
#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_finsert(struct soap *soap, int t, int tt, void *p, size_t index, const void *q, void **x)
{
	(void)soap; (void)t; (void)p; (void)index; (void)q; (void)x; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_web__saveGPOrders:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy web__saveGPOrders type=%d location=%p object=%p\n", t, p, q));
		*(web__saveGPOrders*)p = *(web__saveGPOrders*)q;
		break;
	case SOAP_TYPE_std__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_web__gpOrders:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy web__gpOrders type=%d location=%p object=%p\n", t, p, q));
		*(web__gpOrders*)p = *(web__gpOrders*)q;
		break;
	case SOAP_TYPE_web__saveGPOrdersResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy web__saveGPOrdersResponse type=%d location=%p object=%p\n", t, p, q));
		*(web__saveGPOrdersResponse*)p = *(web__saveGPOrdersResponse*)q;
		break;
	case SOAP_TYPE_web__saveSamplers:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy web__saveSamplers type=%d location=%p object=%p\n", t, p, q));
		*(web__saveSamplers*)p = *(web__saveSamplers*)q;
		break;
	case SOAP_TYPE_web__saveSamplersResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy web__saveSamplersResponse type=%d location=%p object=%p\n", t, p, q));
		*(web__saveSamplersResponse*)p = *(web__saveSamplersResponse*)q;
		break;
	case SOAP_TYPE_web__updatePassword:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy web__updatePassword type=%d location=%p object=%p\n", t, p, q));
		*(web__updatePassword*)p = *(web__updatePassword*)q;
		break;
	case SOAP_TYPE_web__updatePasswordResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy web__updatePasswordResponse type=%d location=%p object=%p\n", t, p, q));
		*(web__updatePasswordResponse*)p = *(web__updatePasswordResponse*)q;
		break;
	case SOAP_TYPE_web__savePoundInfoA:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy web__savePoundInfoA type=%d location=%p object=%p\n", t, p, q));
		*(web__savePoundInfoA*)p = *(web__savePoundInfoA*)q;
		break;
	case SOAP_TYPE_web__savePoundInfoAResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy web__savePoundInfoAResponse type=%d location=%p object=%p\n", t, p, q));
		*(web__savePoundInfoAResponse*)p = *(web__savePoundInfoAResponse*)q;
		break;
	case SOAP_TYPE_web__saveCheckingInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy web__saveCheckingInfo type=%d location=%p object=%p\n", t, p, q));
		*(web__saveCheckingInfo*)p = *(web__saveCheckingInfo*)q;
		break;
	case SOAP_TYPE_web__checkingInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy web__checkingInfo type=%d location=%p object=%p\n", t, p, q));
		*(web__checkingInfo*)p = *(web__checkingInfo*)q;
		break;
	case SOAP_TYPE_web__saveCheckingInfoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy web__saveCheckingInfoResponse type=%d location=%p object=%p\n", t, p, q));
		*(web__saveCheckingInfoResponse*)p = *(web__saveCheckingInfoResponse*)q;
		break;
	case SOAP_TYPE_web__saveGrainUser:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy web__saveGrainUser type=%d location=%p object=%p\n", t, p, q));
		*(web__saveGrainUser*)p = *(web__saveGrainUser*)q;
		break;
	case SOAP_TYPE_web__saveGrainUserResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy web__saveGrainUserResponse type=%d location=%p object=%p\n", t, p, q));
		*(web__saveGrainUserResponse*)p = *(web__saveGrainUserResponse*)q;
		break;
	case SOAP_TYPE_web__savePoundInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy web__savePoundInfo type=%d location=%p object=%p\n", t, p, q));
		*(web__savePoundInfo*)p = *(web__savePoundInfo*)q;
		break;
	case SOAP_TYPE_web__poundInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy web__poundInfo type=%d location=%p object=%p\n", t, p, q));
		*(web__poundInfo*)p = *(web__poundInfo*)q;
		break;
	case SOAP_TYPE_web__savePoundInfoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy web__savePoundInfoResponse type=%d location=%p object=%p\n", t, p, q));
		*(web__savePoundInfoResponse*)p = *(web__savePoundInfoResponse*)q;
		break;
	case SOAP_TYPE_web__saveVehicleInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy web__saveVehicleInfo type=%d location=%p object=%p\n", t, p, q));
		*(web__saveVehicleInfo*)p = *(web__saveVehicleInfo*)q;
		break;
	case SOAP_TYPE_web__saveVehicleInfoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy web__saveVehicleInfoResponse type=%d location=%p object=%p\n", t, p, q));
		*(web__saveVehicleInfoResponse*)p = *(web__saveVehicleInfoResponse*)q;
		break;
	case SOAP_TYPE_web__login:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy web__login type=%d location=%p object=%p\n", t, p, q));
		*(web__login*)p = *(web__login*)q;
		break;
	case SOAP_TYPE_web__loginResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy web__loginResponse type=%d location=%p object=%p\n", t, p, q));
		*(web__loginResponse*)p = *(web__loginResponse*)q;
		break;
	case SOAP_TYPE_web__user:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy web__user type=%d location=%p object=%p\n", t, p, q));
		*(web__user*)p = *(web__user*)q;
		break;
	case SOAP_TYPE___web__updatePassword:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __web__updatePassword type=%d location=%p object=%p\n", t, p, q));
		*(struct __web__updatePassword*)p = *(struct __web__updatePassword*)q;
		break;
	case SOAP_TYPE___web__saveVehicleInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __web__saveVehicleInfo type=%d location=%p object=%p\n", t, p, q));
		*(struct __web__saveVehicleInfo*)p = *(struct __web__saveVehicleInfo*)q;
		break;
	case SOAP_TYPE___web__saveGrainUser:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __web__saveGrainUser type=%d location=%p object=%p\n", t, p, q));
		*(struct __web__saveGrainUser*)p = *(struct __web__saveGrainUser*)q;
		break;
	case SOAP_TYPE___web__savePoundInfoA:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __web__savePoundInfoA type=%d location=%p object=%p\n", t, p, q));
		*(struct __web__savePoundInfoA*)p = *(struct __web__savePoundInfoA*)q;
		break;
	case SOAP_TYPE___web__savePoundInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __web__savePoundInfo type=%d location=%p object=%p\n", t, p, q));
		*(struct __web__savePoundInfo*)p = *(struct __web__savePoundInfo*)q;
		break;
	case SOAP_TYPE___web__saveGPOrders:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __web__saveGPOrders type=%d location=%p object=%p\n", t, p, q));
		*(struct __web__saveGPOrders*)p = *(struct __web__saveGPOrders*)q;
		break;
	case SOAP_TYPE___web__saveSamplers:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __web__saveSamplers type=%d location=%p object=%p\n", t, p, q));
		*(struct __web__saveSamplers*)p = *(struct __web__saveSamplers*)q;
		break;
	case SOAP_TYPE___web__saveCheckingInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __web__saveCheckingInfo type=%d location=%p object=%p\n", t, p, q));
		*(struct __web__saveCheckingInfo*)p = *(struct __web__saveCheckingInfo*)q;
		break;
	case SOAP_TYPE___web__login:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __web__login type=%d location=%p object=%p\n", t, p, q));
		*(struct __web__login*)p = *(struct __web__login*)q;
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Header type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Code type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Detail type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Reason type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Fault type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
		break;
#endif
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", t, tt));
	}
}
#ifdef WIN32
#pragma warning(pop)
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	a = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return a;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_new_byte(struct soap *soap, int n)
{
	char *a = static_cast<char *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char)));
	for (char *p = a; p && n--; ++p)
		soap_default_byte(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	if (soap_out_byte(soap, tag ? tag : "byte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	a = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return a;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_new_int(struct soap *soap, int n)
{
	int *a = static_cast<int *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(int)));
	for (int *p = a; p && n--; ++p)
		soap_default_int(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	if (soap_out_int(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (LONG64)false, "false" },
	{ (LONG64)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
	return soap_code_str(soap_codes_bool, n != 0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2bool(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_new_bool(struct soap *soap, int n)
{
	bool *a = static_cast<bool *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(bool)));
	for (bool *p = a; p && n--; ++p)
		soap_default_bool(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	if (soap_out_bool(soap, tag ? tag : "boolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_std__string, SOAP_TYPE_std__string, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::string *p;
	size_t k = sizeof(std::string);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::string);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::string, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::string location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_std__string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void web__user::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->web__user::AD_USCOREClient_USCOREID);
	soap_default_int(soap, &this->web__user::AD_USCOREOrg_USCOREID);
	soap_default_int(soap, &this->web__user::AD_USCOREROLE_USCOREID);
	soap_default_int(soap, &this->web__user::AD_USCOREUSER_USCOREID);
	this->web__user::MESSAGE = NULL;
	this->web__user::NAME = NULL;
	/* transient soap skipped */
}

void web__user::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->web__user::MESSAGE);
	soap_serialize_PointerTostd__string(soap, &this->web__user::NAME);
#endif
}

int web__user::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_web__user(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_web__user(struct soap *soap, const char *tag, int id, const web__user *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_web__user), type))
		return soap->error;
	if (soap_out_int(soap, "AD_Client_ID", -1, &a->web__user::AD_USCOREClient_USCOREID, ""))
		return soap->error;
	if (soap_out_int(soap, "AD_Org_ID", -1, &a->web__user::AD_USCOREOrg_USCOREID, ""))
		return soap->error;
	if (soap_out_int(soap, "AD_ROLE_ID", -1, &a->web__user::AD_USCOREROLE_USCOREID, ""))
		return soap->error;
	if (soap_out_int(soap, "AD_USER_ID", -1, &a->web__user::AD_USCOREUSER_USCOREID, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "MESSAGE", -1, &a->web__user::MESSAGE, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "NAME", -1, &a->web__user::NAME, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *web__user::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_web__user(soap, tag, this, type);
}

SOAP_FMAC3 web__user * SOAP_FMAC4 soap_in_web__user(struct soap *soap, const char *tag, web__user *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (web__user *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_web__user, sizeof(web__user), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_web__user)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (web__user *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_AD_USCOREClient_USCOREID1 = 1;
	size_t soap_flag_AD_USCOREOrg_USCOREID1 = 1;
	size_t soap_flag_AD_USCOREROLE_USCOREID1 = 1;
	size_t soap_flag_AD_USCOREUSER_USCOREID1 = 1;
	size_t soap_flag_MESSAGE1 = 1;
	size_t soap_flag_NAME1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AD_USCOREClient_USCOREID1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "AD_Client_ID", &a->web__user::AD_USCOREClient_USCOREID, "xsd:int"))
				{	soap_flag_AD_USCOREClient_USCOREID1--;
					continue;
				}
			}
			if (soap_flag_AD_USCOREOrg_USCOREID1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "AD_Org_ID", &a->web__user::AD_USCOREOrg_USCOREID, "xsd:int"))
				{	soap_flag_AD_USCOREOrg_USCOREID1--;
					continue;
				}
			}
			if (soap_flag_AD_USCOREROLE_USCOREID1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "AD_ROLE_ID", &a->web__user::AD_USCOREROLE_USCOREID, "xsd:int"))
				{	soap_flag_AD_USCOREROLE_USCOREID1--;
					continue;
				}
			}
			if (soap_flag_AD_USCOREUSER_USCOREID1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "AD_USER_ID", &a->web__user::AD_USCOREUSER_USCOREID, "xsd:int"))
				{	soap_flag_AD_USCOREUSER_USCOREID1--;
					continue;
				}
			}
			if (soap_flag_MESSAGE1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "MESSAGE", &a->web__user::MESSAGE, "xsd:string"))
				{	soap_flag_MESSAGE1--;
					continue;
				}
			}
			if (soap_flag_NAME1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "NAME", &a->web__user::NAME, "xsd:string"))
				{	soap_flag_NAME1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AD_USCOREClient_USCOREID1 > 0 || soap_flag_AD_USCOREOrg_USCOREID1 > 0 || soap_flag_AD_USCOREROLE_USCOREID1 > 0 || soap_flag_AD_USCOREUSER_USCOREID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (web__user *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_web__user, SOAP_TYPE_web__user, sizeof(web__user), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 web__user * SOAP_FMAC2 soap_instantiate_web__user(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_web__user(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	web__user *p;
	size_t k = sizeof(web__user);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_web__user, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, web__user);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, web__user, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated web__user location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int web__user::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_web__user(soap, tag ? tag : "web:user", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *web__user::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_web__user(soap, this, tag, type);
}

SOAP_FMAC3 web__user * SOAP_FMAC4 soap_get_web__user(struct soap *soap, web__user *p, const char *tag, const char *type)
{
	if ((p = soap_in_web__user(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void web__loginResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->web__loginResponse::return_ = NULL;
	/* transient soap skipped */
}

void web__loginResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToweb__user(soap, &this->web__loginResponse::return_);
#endif
}

int web__loginResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_web__loginResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_web__loginResponse(struct soap *soap, const char *tag, int id, const web__loginResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_web__loginResponse), type))
		return soap->error;
	if (soap_out_PointerToweb__user(soap, "return", -1, &a->web__loginResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *web__loginResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_web__loginResponse(soap, tag, this, type);
}

SOAP_FMAC3 web__loginResponse * SOAP_FMAC4 soap_in_web__loginResponse(struct soap *soap, const char *tag, web__loginResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (web__loginResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_web__loginResponse, sizeof(web__loginResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_web__loginResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (web__loginResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_return_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToweb__user(soap, "return", &a->web__loginResponse::return_, "web:user"))
				{	soap_flag_return_1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (web__loginResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_web__loginResponse, SOAP_TYPE_web__loginResponse, sizeof(web__loginResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 web__loginResponse * SOAP_FMAC2 soap_instantiate_web__loginResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_web__loginResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	web__loginResponse *p;
	size_t k = sizeof(web__loginResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_web__loginResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, web__loginResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, web__loginResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated web__loginResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int web__loginResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_web__loginResponse(soap, tag ? tag : "web:loginResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *web__loginResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_web__loginResponse(soap, this, tag, type);
}

SOAP_FMAC3 web__loginResponse * SOAP_FMAC4 soap_get_web__loginResponse(struct soap *soap, web__loginResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_web__loginResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void web__login::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->web__login::arg0 = NULL;
	this->web__login::arg1 = NULL;
	/* transient soap skipped */
}

void web__login::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->web__login::arg0);
	soap_serialize_PointerTostd__string(soap, &this->web__login::arg1);
#endif
}

int web__login::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_web__login(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_web__login(struct soap *soap, const char *tag, int id, const web__login *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_web__login), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &a->web__login::arg0, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg1", -1, &a->web__login::arg1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *web__login::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_web__login(soap, tag, this, type);
}

SOAP_FMAC3 web__login * SOAP_FMAC4 soap_in_web__login(struct soap *soap, const char *tag, web__login *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (web__login *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_web__login, sizeof(web__login), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_web__login)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (web__login *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_arg11 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg0", &a->web__login::arg0, "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap_flag_arg11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg1", &a->web__login::arg1, "xsd:string"))
				{	soap_flag_arg11--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (web__login *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_web__login, SOAP_TYPE_web__login, sizeof(web__login), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 web__login * SOAP_FMAC2 soap_instantiate_web__login(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_web__login(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	web__login *p;
	size_t k = sizeof(web__login);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_web__login, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, web__login);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, web__login, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated web__login location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int web__login::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_web__login(soap, tag ? tag : "web:login", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *web__login::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_web__login(soap, this, tag, type);
}

SOAP_FMAC3 web__login * SOAP_FMAC4 soap_get_web__login(struct soap *soap, web__login *p, const char *tag, const char *type)
{
	if ((p = soap_in_web__login(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void web__saveVehicleInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->web__saveVehicleInfoResponse::return_ = NULL;
	/* transient soap skipped */
}

void web__saveVehicleInfoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->web__saveVehicleInfoResponse::return_);
#endif
}

int web__saveVehicleInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_web__saveVehicleInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_web__saveVehicleInfoResponse(struct soap *soap, const char *tag, int id, const web__saveVehicleInfoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_web__saveVehicleInfoResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "return", -1, &a->web__saveVehicleInfoResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *web__saveVehicleInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_web__saveVehicleInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 web__saveVehicleInfoResponse * SOAP_FMAC4 soap_in_web__saveVehicleInfoResponse(struct soap *soap, const char *tag, web__saveVehicleInfoResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (web__saveVehicleInfoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_web__saveVehicleInfoResponse, sizeof(web__saveVehicleInfoResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_web__saveVehicleInfoResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (web__saveVehicleInfoResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_return_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "return", &a->web__saveVehicleInfoResponse::return_, "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (web__saveVehicleInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_web__saveVehicleInfoResponse, SOAP_TYPE_web__saveVehicleInfoResponse, sizeof(web__saveVehicleInfoResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 web__saveVehicleInfoResponse * SOAP_FMAC2 soap_instantiate_web__saveVehicleInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_web__saveVehicleInfoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	web__saveVehicleInfoResponse *p;
	size_t k = sizeof(web__saveVehicleInfoResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_web__saveVehicleInfoResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, web__saveVehicleInfoResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, web__saveVehicleInfoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated web__saveVehicleInfoResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int web__saveVehicleInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_web__saveVehicleInfoResponse(soap, tag ? tag : "web:saveVehicleInfoResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *web__saveVehicleInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_web__saveVehicleInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 web__saveVehicleInfoResponse * SOAP_FMAC4 soap_get_web__saveVehicleInfoResponse(struct soap *soap, web__saveVehicleInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_web__saveVehicleInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void web__saveVehicleInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->web__saveVehicleInfo::arg0 = NULL;
	this->web__saveVehicleInfo::arg1 = NULL;
	this->web__saveVehicleInfo::arg2 = NULL;
	this->web__saveVehicleInfo::arg3 = NULL;
	this->web__saveVehicleInfo::arg4 = NULL;
	this->web__saveVehicleInfo::arg5 = NULL;
	this->web__saveVehicleInfo::arg6 = NULL;
	/* transient soap skipped */
}

void web__saveVehicleInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->web__saveVehicleInfo::arg0);
	soap_serialize_PointerTostd__string(soap, &this->web__saveVehicleInfo::arg1);
	soap_serialize_PointerTostd__string(soap, &this->web__saveVehicleInfo::arg2);
	soap_serialize_PointerTostd__string(soap, &this->web__saveVehicleInfo::arg3);
	soap_serialize_PointerTostd__string(soap, &this->web__saveVehicleInfo::arg4);
	soap_serialize_PointerTostd__string(soap, &this->web__saveVehicleInfo::arg5);
	soap_serialize_PointerTostd__string(soap, &this->web__saveVehicleInfo::arg6);
#endif
}

int web__saveVehicleInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_web__saveVehicleInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_web__saveVehicleInfo(struct soap *soap, const char *tag, int id, const web__saveVehicleInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_web__saveVehicleInfo), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &a->web__saveVehicleInfo::arg0, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg1", -1, &a->web__saveVehicleInfo::arg1, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg2", -1, &a->web__saveVehicleInfo::arg2, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg3", -1, &a->web__saveVehicleInfo::arg3, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg4", -1, &a->web__saveVehicleInfo::arg4, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg5", -1, &a->web__saveVehicleInfo::arg5, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg6", -1, &a->web__saveVehicleInfo::arg6, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *web__saveVehicleInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_web__saveVehicleInfo(soap, tag, this, type);
}

SOAP_FMAC3 web__saveVehicleInfo * SOAP_FMAC4 soap_in_web__saveVehicleInfo(struct soap *soap, const char *tag, web__saveVehicleInfo *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (web__saveVehicleInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_web__saveVehicleInfo, sizeof(web__saveVehicleInfo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_web__saveVehicleInfo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (web__saveVehicleInfo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_arg11 = 1;
	size_t soap_flag_arg21 = 1;
	size_t soap_flag_arg31 = 1;
	size_t soap_flag_arg41 = 1;
	size_t soap_flag_arg51 = 1;
	size_t soap_flag_arg61 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg0", &a->web__saveVehicleInfo::arg0, "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap_flag_arg11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg1", &a->web__saveVehicleInfo::arg1, "xsd:string"))
				{	soap_flag_arg11--;
					continue;
				}
			}
			if (soap_flag_arg21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg2", &a->web__saveVehicleInfo::arg2, "xsd:string"))
				{	soap_flag_arg21--;
					continue;
				}
			}
			if (soap_flag_arg31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg3", &a->web__saveVehicleInfo::arg3, "xsd:string"))
				{	soap_flag_arg31--;
					continue;
				}
			}
			if (soap_flag_arg41 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg4", &a->web__saveVehicleInfo::arg4, "xsd:string"))
				{	soap_flag_arg41--;
					continue;
				}
			}
			if (soap_flag_arg51 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg5", &a->web__saveVehicleInfo::arg5, "xsd:string"))
				{	soap_flag_arg51--;
					continue;
				}
			}
			if (soap_flag_arg61 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg6", &a->web__saveVehicleInfo::arg6, "xsd:string"))
				{	soap_flag_arg61--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (web__saveVehicleInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_web__saveVehicleInfo, SOAP_TYPE_web__saveVehicleInfo, sizeof(web__saveVehicleInfo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 web__saveVehicleInfo * SOAP_FMAC2 soap_instantiate_web__saveVehicleInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_web__saveVehicleInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	web__saveVehicleInfo *p;
	size_t k = sizeof(web__saveVehicleInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_web__saveVehicleInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, web__saveVehicleInfo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, web__saveVehicleInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated web__saveVehicleInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int web__saveVehicleInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_web__saveVehicleInfo(soap, tag ? tag : "web:saveVehicleInfo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *web__saveVehicleInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_web__saveVehicleInfo(soap, this, tag, type);
}

SOAP_FMAC3 web__saveVehicleInfo * SOAP_FMAC4 soap_get_web__saveVehicleInfo(struct soap *soap, web__saveVehicleInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_web__saveVehicleInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void web__savePoundInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->web__savePoundInfoResponse::return_ = NULL;
	/* transient soap skipped */
}

void web__savePoundInfoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->web__savePoundInfoResponse::return_);
#endif
}

int web__savePoundInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_web__savePoundInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_web__savePoundInfoResponse(struct soap *soap, const char *tag, int id, const web__savePoundInfoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_web__savePoundInfoResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "return", -1, &a->web__savePoundInfoResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *web__savePoundInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_web__savePoundInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 web__savePoundInfoResponse * SOAP_FMAC4 soap_in_web__savePoundInfoResponse(struct soap *soap, const char *tag, web__savePoundInfoResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (web__savePoundInfoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_web__savePoundInfoResponse, sizeof(web__savePoundInfoResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_web__savePoundInfoResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (web__savePoundInfoResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_return_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "return", &a->web__savePoundInfoResponse::return_, "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (web__savePoundInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_web__savePoundInfoResponse, SOAP_TYPE_web__savePoundInfoResponse, sizeof(web__savePoundInfoResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 web__savePoundInfoResponse * SOAP_FMAC2 soap_instantiate_web__savePoundInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_web__savePoundInfoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	web__savePoundInfoResponse *p;
	size_t k = sizeof(web__savePoundInfoResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_web__savePoundInfoResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, web__savePoundInfoResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, web__savePoundInfoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated web__savePoundInfoResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int web__savePoundInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_web__savePoundInfoResponse(soap, tag ? tag : "web:savePoundInfoResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *web__savePoundInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_web__savePoundInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 web__savePoundInfoResponse * SOAP_FMAC4 soap_get_web__savePoundInfoResponse(struct soap *soap, web__savePoundInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_web__savePoundInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void web__poundInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->web__poundInfo::ad_USCOREclient_USCOREid);
	soap_default_int(soap, &this->web__poundInfo::ad_USCOREorg_USCOREid);
	soap_default_int(soap, &this->web__poundInfo::ad_USCORErole_USCOREid);
	soap_default_int(soap, &this->web__poundInfo::ad_USCOREuser_USCOREid);
	soap_default_int(soap, &this->web__poundInfo::c_USCOREPoundInfo_USCOREID);
	soap_default_int(soap, &this->web__poundInfo::c_USCOREVehicleInfo_USCOREID);
	this->web__poundInfo::carrierCompany = NULL;
	this->web__poundInfo::carrierCompanyValue = NULL;
	this->web__poundInfo::color = NULL;
	this->web__poundInfo::comments = NULL;
	this->web__poundInfo::deliverCompany = NULL;
	this->web__poundInfo::deliverCompanyValue = NULL;
	this->web__poundInfo::grossDate = NULL;
	this->web__poundInfo::grossWeight = NULL;
	this->web__poundInfo::m_USCOREProduct_USCOREID = NULL;
	this->web__poundInfo::m_USCOREProduct_USCOREIDValue = NULL;
	this->web__poundInfo::packingType = NULL;
	this->web__poundInfo::recipientCompany = NULL;
	this->web__poundInfo::recipientCompanyValue = NULL;
	this->web__poundInfo::tareDate = NULL;
	this->web__poundInfo::tareWeight = NULL;
	this->web__poundInfo::type = NULL;
	/* transient soap skipped */
}

void web__poundInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->web__poundInfo::carrierCompany);
	soap_serialize_PointerTostd__string(soap, &this->web__poundInfo::carrierCompanyValue);
	soap_serialize_PointerTostd__string(soap, &this->web__poundInfo::color);
	soap_serialize_PointerTostd__string(soap, &this->web__poundInfo::comments);
	soap_serialize_PointerTostd__string(soap, &this->web__poundInfo::deliverCompany);
	soap_serialize_PointerTostd__string(soap, &this->web__poundInfo::deliverCompanyValue);
	soap_serialize_PointerTostd__string(soap, &this->web__poundInfo::grossDate);
	soap_serialize_PointerTostd__string(soap, &this->web__poundInfo::grossWeight);
	soap_serialize_PointerTostd__string(soap, &this->web__poundInfo::m_USCOREProduct_USCOREID);
	soap_serialize_PointerTostd__string(soap, &this->web__poundInfo::m_USCOREProduct_USCOREIDValue);
	soap_serialize_PointerTostd__string(soap, &this->web__poundInfo::packingType);
	soap_serialize_PointerTostd__string(soap, &this->web__poundInfo::recipientCompany);
	soap_serialize_PointerTostd__string(soap, &this->web__poundInfo::recipientCompanyValue);
	soap_serialize_PointerTostd__string(soap, &this->web__poundInfo::tareDate);
	soap_serialize_PointerTostd__string(soap, &this->web__poundInfo::tareWeight);
	soap_serialize_PointerTostd__string(soap, &this->web__poundInfo::type);
#endif
}

int web__poundInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_web__poundInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_web__poundInfo(struct soap *soap, const char *tag, int id, const web__poundInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_web__poundInfo), type))
		return soap->error;
	if (soap_out_int(soap, "ad_client_id", -1, &a->web__poundInfo::ad_USCOREclient_USCOREid, ""))
		return soap->error;
	if (soap_out_int(soap, "ad_org_id", -1, &a->web__poundInfo::ad_USCOREorg_USCOREid, ""))
		return soap->error;
	if (soap_out_int(soap, "ad_role_id", -1, &a->web__poundInfo::ad_USCORErole_USCOREid, ""))
		return soap->error;
	if (soap_out_int(soap, "ad_user_id", -1, &a->web__poundInfo::ad_USCOREuser_USCOREid, ""))
		return soap->error;
	if (soap_out_int(soap, "c_PoundInfo_ID", -1, &a->web__poundInfo::c_USCOREPoundInfo_USCOREID, ""))
		return soap->error;
	if (soap_out_int(soap, "c_VehicleInfo_ID", -1, &a->web__poundInfo::c_USCOREVehicleInfo_USCOREID, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "carrierCompany", -1, &a->web__poundInfo::carrierCompany, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "carrierCompanyValue", -1, &a->web__poundInfo::carrierCompanyValue, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "color", -1, &a->web__poundInfo::color, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "comments", -1, &a->web__poundInfo::comments, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "deliverCompany", -1, &a->web__poundInfo::deliverCompany, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "deliverCompanyValue", -1, &a->web__poundInfo::deliverCompanyValue, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "grossDate", -1, &a->web__poundInfo::grossDate, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "grossWeight", -1, &a->web__poundInfo::grossWeight, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "m_Product_ID", -1, &a->web__poundInfo::m_USCOREProduct_USCOREID, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "m_Product_IDValue", -1, &a->web__poundInfo::m_USCOREProduct_USCOREIDValue, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "packingType", -1, &a->web__poundInfo::packingType, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "recipientCompany", -1, &a->web__poundInfo::recipientCompany, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "recipientCompanyValue", -1, &a->web__poundInfo::recipientCompanyValue, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tareDate", -1, &a->web__poundInfo::tareDate, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tareWeight", -1, &a->web__poundInfo::tareWeight, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "type", -1, &a->web__poundInfo::type, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *web__poundInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_web__poundInfo(soap, tag, this, type);
}

SOAP_FMAC3 web__poundInfo * SOAP_FMAC4 soap_in_web__poundInfo(struct soap *soap, const char *tag, web__poundInfo *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (web__poundInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_web__poundInfo, sizeof(web__poundInfo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_web__poundInfo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (web__poundInfo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ad_USCOREclient_USCOREid1 = 1;
	size_t soap_flag_ad_USCOREorg_USCOREid1 = 1;
	size_t soap_flag_ad_USCORErole_USCOREid1 = 1;
	size_t soap_flag_ad_USCOREuser_USCOREid1 = 1;
	size_t soap_flag_c_USCOREPoundInfo_USCOREID1 = 1;
	size_t soap_flag_c_USCOREVehicleInfo_USCOREID1 = 1;
	size_t soap_flag_carrierCompany1 = 1;
	size_t soap_flag_carrierCompanyValue1 = 1;
	size_t soap_flag_color1 = 1;
	size_t soap_flag_comments1 = 1;
	size_t soap_flag_deliverCompany1 = 1;
	size_t soap_flag_deliverCompanyValue1 = 1;
	size_t soap_flag_grossDate1 = 1;
	size_t soap_flag_grossWeight1 = 1;
	size_t soap_flag_m_USCOREProduct_USCOREID1 = 1;
	size_t soap_flag_m_USCOREProduct_USCOREIDValue1 = 1;
	size_t soap_flag_packingType1 = 1;
	size_t soap_flag_recipientCompany1 = 1;
	size_t soap_flag_recipientCompanyValue1 = 1;
	size_t soap_flag_tareDate1 = 1;
	size_t soap_flag_tareWeight1 = 1;
	size_t soap_flag_type1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ad_USCOREclient_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ad_client_id", &a->web__poundInfo::ad_USCOREclient_USCOREid, "xsd:int"))
				{	soap_flag_ad_USCOREclient_USCOREid1--;
					continue;
				}
			}
			if (soap_flag_ad_USCOREorg_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ad_org_id", &a->web__poundInfo::ad_USCOREorg_USCOREid, "xsd:int"))
				{	soap_flag_ad_USCOREorg_USCOREid1--;
					continue;
				}
			}
			if (soap_flag_ad_USCORErole_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ad_role_id", &a->web__poundInfo::ad_USCORErole_USCOREid, "xsd:int"))
				{	soap_flag_ad_USCORErole_USCOREid1--;
					continue;
				}
			}
			if (soap_flag_ad_USCOREuser_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ad_user_id", &a->web__poundInfo::ad_USCOREuser_USCOREid, "xsd:int"))
				{	soap_flag_ad_USCOREuser_USCOREid1--;
					continue;
				}
			}
			if (soap_flag_c_USCOREPoundInfo_USCOREID1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "c_PoundInfo_ID", &a->web__poundInfo::c_USCOREPoundInfo_USCOREID, "xsd:int"))
				{	soap_flag_c_USCOREPoundInfo_USCOREID1--;
					continue;
				}
			}
			if (soap_flag_c_USCOREVehicleInfo_USCOREID1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "c_VehicleInfo_ID", &a->web__poundInfo::c_USCOREVehicleInfo_USCOREID, "xsd:int"))
				{	soap_flag_c_USCOREVehicleInfo_USCOREID1--;
					continue;
				}
			}
			if (soap_flag_carrierCompany1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "carrierCompany", &a->web__poundInfo::carrierCompany, "xsd:string"))
				{	soap_flag_carrierCompany1--;
					continue;
				}
			}
			if (soap_flag_carrierCompanyValue1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "carrierCompanyValue", &a->web__poundInfo::carrierCompanyValue, "xsd:string"))
				{	soap_flag_carrierCompanyValue1--;
					continue;
				}
			}
			if (soap_flag_color1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "color", &a->web__poundInfo::color, "xsd:string"))
				{	soap_flag_color1--;
					continue;
				}
			}
			if (soap_flag_comments1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "comments", &a->web__poundInfo::comments, "xsd:string"))
				{	soap_flag_comments1--;
					continue;
				}
			}
			if (soap_flag_deliverCompany1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "deliverCompany", &a->web__poundInfo::deliverCompany, "xsd:string"))
				{	soap_flag_deliverCompany1--;
					continue;
				}
			}
			if (soap_flag_deliverCompanyValue1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "deliverCompanyValue", &a->web__poundInfo::deliverCompanyValue, "xsd:string"))
				{	soap_flag_deliverCompanyValue1--;
					continue;
				}
			}
			if (soap_flag_grossDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "grossDate", &a->web__poundInfo::grossDate, "xsd:string"))
				{	soap_flag_grossDate1--;
					continue;
				}
			}
			if (soap_flag_grossWeight1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "grossWeight", &a->web__poundInfo::grossWeight, "xsd:string"))
				{	soap_flag_grossWeight1--;
					continue;
				}
			}
			if (soap_flag_m_USCOREProduct_USCOREID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "m_Product_ID", &a->web__poundInfo::m_USCOREProduct_USCOREID, "xsd:string"))
				{	soap_flag_m_USCOREProduct_USCOREID1--;
					continue;
				}
			}
			if (soap_flag_m_USCOREProduct_USCOREIDValue1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "m_Product_IDValue", &a->web__poundInfo::m_USCOREProduct_USCOREIDValue, "xsd:string"))
				{	soap_flag_m_USCOREProduct_USCOREIDValue1--;
					continue;
				}
			}
			if (soap_flag_packingType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "packingType", &a->web__poundInfo::packingType, "xsd:string"))
				{	soap_flag_packingType1--;
					continue;
				}
			}
			if (soap_flag_recipientCompany1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "recipientCompany", &a->web__poundInfo::recipientCompany, "xsd:string"))
				{	soap_flag_recipientCompany1--;
					continue;
				}
			}
			if (soap_flag_recipientCompanyValue1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "recipientCompanyValue", &a->web__poundInfo::recipientCompanyValue, "xsd:string"))
				{	soap_flag_recipientCompanyValue1--;
					continue;
				}
			}
			if (soap_flag_tareDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tareDate", &a->web__poundInfo::tareDate, "xsd:string"))
				{	soap_flag_tareDate1--;
					continue;
				}
			}
			if (soap_flag_tareWeight1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tareWeight", &a->web__poundInfo::tareWeight, "xsd:string"))
				{	soap_flag_tareWeight1--;
					continue;
				}
			}
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "type", &a->web__poundInfo::type, "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ad_USCOREclient_USCOREid1 > 0 || soap_flag_ad_USCOREorg_USCOREid1 > 0 || soap_flag_ad_USCORErole_USCOREid1 > 0 || soap_flag_ad_USCOREuser_USCOREid1 > 0 || soap_flag_c_USCOREPoundInfo_USCOREID1 > 0 || soap_flag_c_USCOREVehicleInfo_USCOREID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (web__poundInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_web__poundInfo, SOAP_TYPE_web__poundInfo, sizeof(web__poundInfo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 web__poundInfo * SOAP_FMAC2 soap_instantiate_web__poundInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_web__poundInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	web__poundInfo *p;
	size_t k = sizeof(web__poundInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_web__poundInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, web__poundInfo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, web__poundInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated web__poundInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int web__poundInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_web__poundInfo(soap, tag ? tag : "web:poundInfo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *web__poundInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_web__poundInfo(soap, this, tag, type);
}

SOAP_FMAC3 web__poundInfo * SOAP_FMAC4 soap_get_web__poundInfo(struct soap *soap, web__poundInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_web__poundInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void web__savePoundInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->web__savePoundInfo::arg0 = NULL;
	/* transient soap skipped */
}

void web__savePoundInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToweb__poundInfo(soap, &this->web__savePoundInfo::arg0);
#endif
}

int web__savePoundInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_web__savePoundInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_web__savePoundInfo(struct soap *soap, const char *tag, int id, const web__savePoundInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_web__savePoundInfo), type))
		return soap->error;
	if (soap_out_PointerToweb__poundInfo(soap, "arg0", -1, &a->web__savePoundInfo::arg0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *web__savePoundInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_web__savePoundInfo(soap, tag, this, type);
}

SOAP_FMAC3 web__savePoundInfo * SOAP_FMAC4 soap_in_web__savePoundInfo(struct soap *soap, const char *tag, web__savePoundInfo *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (web__savePoundInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_web__savePoundInfo, sizeof(web__savePoundInfo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_web__savePoundInfo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (web__savePoundInfo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToweb__poundInfo(soap, "arg0", &a->web__savePoundInfo::arg0, "web:poundInfo"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (web__savePoundInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_web__savePoundInfo, SOAP_TYPE_web__savePoundInfo, sizeof(web__savePoundInfo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 web__savePoundInfo * SOAP_FMAC2 soap_instantiate_web__savePoundInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_web__savePoundInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	web__savePoundInfo *p;
	size_t k = sizeof(web__savePoundInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_web__savePoundInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, web__savePoundInfo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, web__savePoundInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated web__savePoundInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int web__savePoundInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_web__savePoundInfo(soap, tag ? tag : "web:savePoundInfo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *web__savePoundInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_web__savePoundInfo(soap, this, tag, type);
}

SOAP_FMAC3 web__savePoundInfo * SOAP_FMAC4 soap_get_web__savePoundInfo(struct soap *soap, web__savePoundInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_web__savePoundInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void web__saveGrainUserResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->web__saveGrainUserResponse::return_ = NULL;
	/* transient soap skipped */
}

void web__saveGrainUserResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->web__saveGrainUserResponse::return_);
#endif
}

int web__saveGrainUserResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_web__saveGrainUserResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_web__saveGrainUserResponse(struct soap *soap, const char *tag, int id, const web__saveGrainUserResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_web__saveGrainUserResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "return", -1, &a->web__saveGrainUserResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *web__saveGrainUserResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_web__saveGrainUserResponse(soap, tag, this, type);
}

SOAP_FMAC3 web__saveGrainUserResponse * SOAP_FMAC4 soap_in_web__saveGrainUserResponse(struct soap *soap, const char *tag, web__saveGrainUserResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (web__saveGrainUserResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_web__saveGrainUserResponse, sizeof(web__saveGrainUserResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_web__saveGrainUserResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (web__saveGrainUserResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_return_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "return", &a->web__saveGrainUserResponse::return_, "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (web__saveGrainUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_web__saveGrainUserResponse, SOAP_TYPE_web__saveGrainUserResponse, sizeof(web__saveGrainUserResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 web__saveGrainUserResponse * SOAP_FMAC2 soap_instantiate_web__saveGrainUserResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_web__saveGrainUserResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	web__saveGrainUserResponse *p;
	size_t k = sizeof(web__saveGrainUserResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_web__saveGrainUserResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, web__saveGrainUserResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, web__saveGrainUserResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated web__saveGrainUserResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int web__saveGrainUserResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_web__saveGrainUserResponse(soap, tag ? tag : "web:saveGrainUserResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *web__saveGrainUserResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_web__saveGrainUserResponse(soap, this, tag, type);
}

SOAP_FMAC3 web__saveGrainUserResponse * SOAP_FMAC4 soap_get_web__saveGrainUserResponse(struct soap *soap, web__saveGrainUserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_web__saveGrainUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void web__saveGrainUser::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->web__saveGrainUser::arg0 = NULL;
	this->web__saveGrainUser::arg1 = NULL;
	this->web__saveGrainUser::arg2 = NULL;
	this->web__saveGrainUser::arg3 = NULL;
	this->web__saveGrainUser::arg4 = NULL;
	this->web__saveGrainUser::arg5 = NULL;
	this->web__saveGrainUser::arg6 = NULL;
	/* transient soap skipped */
}

void web__saveGrainUser::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->web__saveGrainUser::arg0);
	soap_serialize_PointerTostd__string(soap, &this->web__saveGrainUser::arg1);
	soap_serialize_PointerTostd__string(soap, &this->web__saveGrainUser::arg2);
	soap_serialize_PointerTostd__string(soap, &this->web__saveGrainUser::arg3);
	soap_serialize_PointerTostd__string(soap, &this->web__saveGrainUser::arg4);
	soap_serialize_PointerTostd__string(soap, &this->web__saveGrainUser::arg5);
	soap_serialize_PointerTostd__string(soap, &this->web__saveGrainUser::arg6);
#endif
}

int web__saveGrainUser::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_web__saveGrainUser(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_web__saveGrainUser(struct soap *soap, const char *tag, int id, const web__saveGrainUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_web__saveGrainUser), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &a->web__saveGrainUser::arg0, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg1", -1, &a->web__saveGrainUser::arg1, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg2", -1, &a->web__saveGrainUser::arg2, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg3", -1, &a->web__saveGrainUser::arg3, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg4", -1, &a->web__saveGrainUser::arg4, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg5", -1, &a->web__saveGrainUser::arg5, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg6", -1, &a->web__saveGrainUser::arg6, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *web__saveGrainUser::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_web__saveGrainUser(soap, tag, this, type);
}

SOAP_FMAC3 web__saveGrainUser * SOAP_FMAC4 soap_in_web__saveGrainUser(struct soap *soap, const char *tag, web__saveGrainUser *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (web__saveGrainUser *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_web__saveGrainUser, sizeof(web__saveGrainUser), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_web__saveGrainUser)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (web__saveGrainUser *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_arg11 = 1;
	size_t soap_flag_arg21 = 1;
	size_t soap_flag_arg31 = 1;
	size_t soap_flag_arg41 = 1;
	size_t soap_flag_arg51 = 1;
	size_t soap_flag_arg61 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg0", &a->web__saveGrainUser::arg0, "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap_flag_arg11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg1", &a->web__saveGrainUser::arg1, "xsd:string"))
				{	soap_flag_arg11--;
					continue;
				}
			}
			if (soap_flag_arg21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg2", &a->web__saveGrainUser::arg2, "xsd:string"))
				{	soap_flag_arg21--;
					continue;
				}
			}
			if (soap_flag_arg31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg3", &a->web__saveGrainUser::arg3, "xsd:string"))
				{	soap_flag_arg31--;
					continue;
				}
			}
			if (soap_flag_arg41 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg4", &a->web__saveGrainUser::arg4, "xsd:string"))
				{	soap_flag_arg41--;
					continue;
				}
			}
			if (soap_flag_arg51 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg5", &a->web__saveGrainUser::arg5, "xsd:string"))
				{	soap_flag_arg51--;
					continue;
				}
			}
			if (soap_flag_arg61 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg6", &a->web__saveGrainUser::arg6, "xsd:string"))
				{	soap_flag_arg61--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (web__saveGrainUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_web__saveGrainUser, SOAP_TYPE_web__saveGrainUser, sizeof(web__saveGrainUser), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 web__saveGrainUser * SOAP_FMAC2 soap_instantiate_web__saveGrainUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_web__saveGrainUser(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	web__saveGrainUser *p;
	size_t k = sizeof(web__saveGrainUser);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_web__saveGrainUser, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, web__saveGrainUser);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, web__saveGrainUser, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated web__saveGrainUser location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int web__saveGrainUser::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_web__saveGrainUser(soap, tag ? tag : "web:saveGrainUser", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *web__saveGrainUser::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_web__saveGrainUser(soap, this, tag, type);
}

SOAP_FMAC3 web__saveGrainUser * SOAP_FMAC4 soap_get_web__saveGrainUser(struct soap *soap, web__saveGrainUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_web__saveGrainUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void web__saveCheckingInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->web__saveCheckingInfoResponse::return_ = NULL;
	/* transient soap skipped */
}

void web__saveCheckingInfoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->web__saveCheckingInfoResponse::return_);
#endif
}

int web__saveCheckingInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_web__saveCheckingInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_web__saveCheckingInfoResponse(struct soap *soap, const char *tag, int id, const web__saveCheckingInfoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_web__saveCheckingInfoResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "return", -1, &a->web__saveCheckingInfoResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *web__saveCheckingInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_web__saveCheckingInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 web__saveCheckingInfoResponse * SOAP_FMAC4 soap_in_web__saveCheckingInfoResponse(struct soap *soap, const char *tag, web__saveCheckingInfoResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (web__saveCheckingInfoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_web__saveCheckingInfoResponse, sizeof(web__saveCheckingInfoResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_web__saveCheckingInfoResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (web__saveCheckingInfoResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_return_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "return", &a->web__saveCheckingInfoResponse::return_, "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (web__saveCheckingInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_web__saveCheckingInfoResponse, SOAP_TYPE_web__saveCheckingInfoResponse, sizeof(web__saveCheckingInfoResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 web__saveCheckingInfoResponse * SOAP_FMAC2 soap_instantiate_web__saveCheckingInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_web__saveCheckingInfoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	web__saveCheckingInfoResponse *p;
	size_t k = sizeof(web__saveCheckingInfoResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_web__saveCheckingInfoResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, web__saveCheckingInfoResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, web__saveCheckingInfoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated web__saveCheckingInfoResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int web__saveCheckingInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_web__saveCheckingInfoResponse(soap, tag ? tag : "web:saveCheckingInfoResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *web__saveCheckingInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_web__saveCheckingInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 web__saveCheckingInfoResponse * SOAP_FMAC4 soap_get_web__saveCheckingInfoResponse(struct soap *soap, web__saveCheckingInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_web__saveCheckingInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void web__checkingInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->web__checkingInfo::abreastimpurity = NULL;
	soap_default_int(soap, &this->web__checkingInfo::ad_USCOREclient_USCOREid);
	soap_default_int(soap, &this->web__checkingInfo::ad_USCOREorg_USCOREid);
	soap_default_int(soap, &this->web__checkingInfo::ad_USCORErole_USCOREid);
	soap_default_int(soap, &this->web__checkingInfo::ad_USCOREuser_USCOREid);
	this->web__checkingInfo::barcodevalue = NULL;
	this->web__checkingInfo::bulkdensity = NULL;
	soap_default_int(soap, &this->web__checkingInfo::c_USCOREcheckinginfo_USCOREid);
	soap_default_int(soap, &this->web__checkingInfo::c_USCOREgporders_USCOREid);
	soap_default_int(soap, &this->web__checkingInfo::c_USCOREvehicleinfo_USCOREid);
	this->web__checkingInfo::comments = NULL;
	this->web__checkingInfo::datecheck = NULL;
	this->web__checkingInfo::fracture = NULL;
	this->web__checkingInfo::heatloss = NULL;
	this->web__checkingInfo::impurity = NULL;
	this->web__checkingInfo::iscomplete = NULL;
	soap_default_bool(soap, &this->web__checkingInfo::issample);
	soap_default_int(soap, &this->web__checkingInfo::m_USCOREproduct_USCOREid);
	this->web__checkingInfo::mildew = NULL;
	soap_default_int(soap, &this->web__checkingInfo::pipe);
	this->web__checkingInfo::sampleno = NULL;
	this->web__checkingInfo::settlementcardid = NULL;
	this->web__checkingInfo::temperature = NULL;
	this->web__checkingInfo::tid = NULL;
	this->web__checkingInfo::watercontent = NULL;
	/* transient soap skipped */
}

void web__checkingInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->web__checkingInfo::abreastimpurity);
	soap_serialize_PointerTostd__string(soap, &this->web__checkingInfo::barcodevalue);
	soap_serialize_PointerTostd__string(soap, &this->web__checkingInfo::bulkdensity);
	soap_serialize_PointerTostd__string(soap, &this->web__checkingInfo::comments);
	soap_serialize_PointerTostd__string(soap, &this->web__checkingInfo::datecheck);
	soap_serialize_PointerTostd__string(soap, &this->web__checkingInfo::fracture);
	soap_serialize_PointerTostd__string(soap, &this->web__checkingInfo::heatloss);
	soap_serialize_PointerTostd__string(soap, &this->web__checkingInfo::impurity);
	soap_serialize_PointerTostd__string(soap, &this->web__checkingInfo::iscomplete);
	soap_serialize_PointerTostd__string(soap, &this->web__checkingInfo::mildew);
	soap_serialize_PointerTostd__string(soap, &this->web__checkingInfo::sampleno);
	soap_serialize_PointerTostd__string(soap, &this->web__checkingInfo::settlementcardid);
	soap_serialize_PointerTostd__string(soap, &this->web__checkingInfo::temperature);
	soap_serialize_PointerTostd__string(soap, &this->web__checkingInfo::tid);
	soap_serialize_PointerTostd__string(soap, &this->web__checkingInfo::watercontent);
#endif
}

int web__checkingInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_web__checkingInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_web__checkingInfo(struct soap *soap, const char *tag, int id, const web__checkingInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_web__checkingInfo), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "abreastimpurity", -1, &a->web__checkingInfo::abreastimpurity, ""))
		return soap->error;
	if (soap_out_int(soap, "ad_client_id", -1, &a->web__checkingInfo::ad_USCOREclient_USCOREid, ""))
		return soap->error;
	if (soap_out_int(soap, "ad_org_id", -1, &a->web__checkingInfo::ad_USCOREorg_USCOREid, ""))
		return soap->error;
	if (soap_out_int(soap, "ad_role_id", -1, &a->web__checkingInfo::ad_USCORErole_USCOREid, ""))
		return soap->error;
	if (soap_out_int(soap, "ad_user_id", -1, &a->web__checkingInfo::ad_USCOREuser_USCOREid, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "barcodevalue", -1, &a->web__checkingInfo::barcodevalue, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "bulkdensity", -1, &a->web__checkingInfo::bulkdensity, ""))
		return soap->error;
	if (soap_out_int(soap, "c_checkinginfo_id", -1, &a->web__checkingInfo::c_USCOREcheckinginfo_USCOREid, ""))
		return soap->error;
	if (soap_out_int(soap, "c_gporders_id", -1, &a->web__checkingInfo::c_USCOREgporders_USCOREid, ""))
		return soap->error;
	if (soap_out_int(soap, "c_vehicleinfo_id", -1, &a->web__checkingInfo::c_USCOREvehicleinfo_USCOREid, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "comments", -1, &a->web__checkingInfo::comments, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "datecheck", -1, &a->web__checkingInfo::datecheck, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "fracture", -1, &a->web__checkingInfo::fracture, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "heatloss", -1, &a->web__checkingInfo::heatloss, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "impurity", -1, &a->web__checkingInfo::impurity, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "iscomplete", -1, &a->web__checkingInfo::iscomplete, ""))
		return soap->error;
	if (soap_out_bool(soap, "issample", -1, &a->web__checkingInfo::issample, ""))
		return soap->error;
	if (soap_out_int(soap, "m_product_id", -1, &a->web__checkingInfo::m_USCOREproduct_USCOREid, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "mildew", -1, &a->web__checkingInfo::mildew, ""))
		return soap->error;
	if (soap_out_int(soap, "pipe", -1, &a->web__checkingInfo::pipe, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "sampleno", -1, &a->web__checkingInfo::sampleno, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "settlementcardid", -1, &a->web__checkingInfo::settlementcardid, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "temperature", -1, &a->web__checkingInfo::temperature, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tid", -1, &a->web__checkingInfo::tid, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "watercontent", -1, &a->web__checkingInfo::watercontent, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *web__checkingInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_web__checkingInfo(soap, tag, this, type);
}

SOAP_FMAC3 web__checkingInfo * SOAP_FMAC4 soap_in_web__checkingInfo(struct soap *soap, const char *tag, web__checkingInfo *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (web__checkingInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_web__checkingInfo, sizeof(web__checkingInfo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_web__checkingInfo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (web__checkingInfo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_abreastimpurity1 = 1;
	size_t soap_flag_ad_USCOREclient_USCOREid1 = 1;
	size_t soap_flag_ad_USCOREorg_USCOREid1 = 1;
	size_t soap_flag_ad_USCORErole_USCOREid1 = 1;
	size_t soap_flag_ad_USCOREuser_USCOREid1 = 1;
	size_t soap_flag_barcodevalue1 = 1;
	size_t soap_flag_bulkdensity1 = 1;
	size_t soap_flag_c_USCOREcheckinginfo_USCOREid1 = 1;
	size_t soap_flag_c_USCOREgporders_USCOREid1 = 1;
	size_t soap_flag_c_USCOREvehicleinfo_USCOREid1 = 1;
	size_t soap_flag_comments1 = 1;
	size_t soap_flag_datecheck1 = 1;
	size_t soap_flag_fracture1 = 1;
	size_t soap_flag_heatloss1 = 1;
	size_t soap_flag_impurity1 = 1;
	size_t soap_flag_iscomplete1 = 1;
	size_t soap_flag_issample1 = 1;
	size_t soap_flag_m_USCOREproduct_USCOREid1 = 1;
	size_t soap_flag_mildew1 = 1;
	size_t soap_flag_pipe1 = 1;
	size_t soap_flag_sampleno1 = 1;
	size_t soap_flag_settlementcardid1 = 1;
	size_t soap_flag_temperature1 = 1;
	size_t soap_flag_tid1 = 1;
	size_t soap_flag_watercontent1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_abreastimpurity1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "abreastimpurity", &a->web__checkingInfo::abreastimpurity, "xsd:string"))
				{	soap_flag_abreastimpurity1--;
					continue;
				}
			}
			if (soap_flag_ad_USCOREclient_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ad_client_id", &a->web__checkingInfo::ad_USCOREclient_USCOREid, "xsd:int"))
				{	soap_flag_ad_USCOREclient_USCOREid1--;
					continue;
				}
			}
			if (soap_flag_ad_USCOREorg_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ad_org_id", &a->web__checkingInfo::ad_USCOREorg_USCOREid, "xsd:int"))
				{	soap_flag_ad_USCOREorg_USCOREid1--;
					continue;
				}
			}
			if (soap_flag_ad_USCORErole_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ad_role_id", &a->web__checkingInfo::ad_USCORErole_USCOREid, "xsd:int"))
				{	soap_flag_ad_USCORErole_USCOREid1--;
					continue;
				}
			}
			if (soap_flag_ad_USCOREuser_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ad_user_id", &a->web__checkingInfo::ad_USCOREuser_USCOREid, "xsd:int"))
				{	soap_flag_ad_USCOREuser_USCOREid1--;
					continue;
				}
			}
			if (soap_flag_barcodevalue1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "barcodevalue", &a->web__checkingInfo::barcodevalue, "xsd:string"))
				{	soap_flag_barcodevalue1--;
					continue;
				}
			}
			if (soap_flag_bulkdensity1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "bulkdensity", &a->web__checkingInfo::bulkdensity, "xsd:string"))
				{	soap_flag_bulkdensity1--;
					continue;
				}
			}
			if (soap_flag_c_USCOREcheckinginfo_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "c_checkinginfo_id", &a->web__checkingInfo::c_USCOREcheckinginfo_USCOREid, "xsd:int"))
				{	soap_flag_c_USCOREcheckinginfo_USCOREid1--;
					continue;
				}
			}
			if (soap_flag_c_USCOREgporders_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "c_gporders_id", &a->web__checkingInfo::c_USCOREgporders_USCOREid, "xsd:int"))
				{	soap_flag_c_USCOREgporders_USCOREid1--;
					continue;
				}
			}
			if (soap_flag_c_USCOREvehicleinfo_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "c_vehicleinfo_id", &a->web__checkingInfo::c_USCOREvehicleinfo_USCOREid, "xsd:int"))
				{	soap_flag_c_USCOREvehicleinfo_USCOREid1--;
					continue;
				}
			}
			if (soap_flag_comments1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "comments", &a->web__checkingInfo::comments, "xsd:string"))
				{	soap_flag_comments1--;
					continue;
				}
			}
			if (soap_flag_datecheck1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "datecheck", &a->web__checkingInfo::datecheck, "xsd:string"))
				{	soap_flag_datecheck1--;
					continue;
				}
			}
			if (soap_flag_fracture1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "fracture", &a->web__checkingInfo::fracture, "xsd:string"))
				{	soap_flag_fracture1--;
					continue;
				}
			}
			if (soap_flag_heatloss1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "heatloss", &a->web__checkingInfo::heatloss, "xsd:string"))
				{	soap_flag_heatloss1--;
					continue;
				}
			}
			if (soap_flag_impurity1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "impurity", &a->web__checkingInfo::impurity, "xsd:string"))
				{	soap_flag_impurity1--;
					continue;
				}
			}
			if (soap_flag_iscomplete1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "iscomplete", &a->web__checkingInfo::iscomplete, "xsd:string"))
				{	soap_flag_iscomplete1--;
					continue;
				}
			}
			if (soap_flag_issample1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "issample", &a->web__checkingInfo::issample, "xsd:boolean"))
				{	soap_flag_issample1--;
					continue;
				}
			}
			if (soap_flag_m_USCOREproduct_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "m_product_id", &a->web__checkingInfo::m_USCOREproduct_USCOREid, "xsd:int"))
				{	soap_flag_m_USCOREproduct_USCOREid1--;
					continue;
				}
			}
			if (soap_flag_mildew1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "mildew", &a->web__checkingInfo::mildew, "xsd:string"))
				{	soap_flag_mildew1--;
					continue;
				}
			}
			if (soap_flag_pipe1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "pipe", &a->web__checkingInfo::pipe, "xsd:int"))
				{	soap_flag_pipe1--;
					continue;
				}
			}
			if (soap_flag_sampleno1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "sampleno", &a->web__checkingInfo::sampleno, "xsd:string"))
				{	soap_flag_sampleno1--;
					continue;
				}
			}
			if (soap_flag_settlementcardid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "settlementcardid", &a->web__checkingInfo::settlementcardid, "xsd:string"))
				{	soap_flag_settlementcardid1--;
					continue;
				}
			}
			if (soap_flag_temperature1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "temperature", &a->web__checkingInfo::temperature, "xsd:string"))
				{	soap_flag_temperature1--;
					continue;
				}
			}
			if (soap_flag_tid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tid", &a->web__checkingInfo::tid, "xsd:string"))
				{	soap_flag_tid1--;
					continue;
				}
			}
			if (soap_flag_watercontent1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "watercontent", &a->web__checkingInfo::watercontent, "xsd:string"))
				{	soap_flag_watercontent1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ad_USCOREclient_USCOREid1 > 0 || soap_flag_ad_USCOREorg_USCOREid1 > 0 || soap_flag_ad_USCORErole_USCOREid1 > 0 || soap_flag_ad_USCOREuser_USCOREid1 > 0 || soap_flag_c_USCOREcheckinginfo_USCOREid1 > 0 || soap_flag_c_USCOREgporders_USCOREid1 > 0 || soap_flag_c_USCOREvehicleinfo_USCOREid1 > 0 || soap_flag_issample1 > 0 || soap_flag_m_USCOREproduct_USCOREid1 > 0 || soap_flag_pipe1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (web__checkingInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_web__checkingInfo, SOAP_TYPE_web__checkingInfo, sizeof(web__checkingInfo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 web__checkingInfo * SOAP_FMAC2 soap_instantiate_web__checkingInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_web__checkingInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	web__checkingInfo *p;
	size_t k = sizeof(web__checkingInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_web__checkingInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, web__checkingInfo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, web__checkingInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated web__checkingInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int web__checkingInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_web__checkingInfo(soap, tag ? tag : "web:checkingInfo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *web__checkingInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_web__checkingInfo(soap, this, tag, type);
}

SOAP_FMAC3 web__checkingInfo * SOAP_FMAC4 soap_get_web__checkingInfo(struct soap *soap, web__checkingInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_web__checkingInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void web__saveCheckingInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->web__saveCheckingInfo::arg0 = NULL;
	/* transient soap skipped */
}

void web__saveCheckingInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToweb__checkingInfo(soap, &this->web__saveCheckingInfo::arg0);
#endif
}

int web__saveCheckingInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_web__saveCheckingInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_web__saveCheckingInfo(struct soap *soap, const char *tag, int id, const web__saveCheckingInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_web__saveCheckingInfo), type))
		return soap->error;
	if (soap_out_PointerToweb__checkingInfo(soap, "arg0", -1, &a->web__saveCheckingInfo::arg0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *web__saveCheckingInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_web__saveCheckingInfo(soap, tag, this, type);
}

SOAP_FMAC3 web__saveCheckingInfo * SOAP_FMAC4 soap_in_web__saveCheckingInfo(struct soap *soap, const char *tag, web__saveCheckingInfo *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (web__saveCheckingInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_web__saveCheckingInfo, sizeof(web__saveCheckingInfo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_web__saveCheckingInfo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (web__saveCheckingInfo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToweb__checkingInfo(soap, "arg0", &a->web__saveCheckingInfo::arg0, "web:checkingInfo"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (web__saveCheckingInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_web__saveCheckingInfo, SOAP_TYPE_web__saveCheckingInfo, sizeof(web__saveCheckingInfo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 web__saveCheckingInfo * SOAP_FMAC2 soap_instantiate_web__saveCheckingInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_web__saveCheckingInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	web__saveCheckingInfo *p;
	size_t k = sizeof(web__saveCheckingInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_web__saveCheckingInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, web__saveCheckingInfo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, web__saveCheckingInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated web__saveCheckingInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int web__saveCheckingInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_web__saveCheckingInfo(soap, tag ? tag : "web:saveCheckingInfo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *web__saveCheckingInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_web__saveCheckingInfo(soap, this, tag, type);
}

SOAP_FMAC3 web__saveCheckingInfo * SOAP_FMAC4 soap_get_web__saveCheckingInfo(struct soap *soap, web__saveCheckingInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_web__saveCheckingInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void web__savePoundInfoAResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->web__savePoundInfoAResponse::return_ = NULL;
	/* transient soap skipped */
}

void web__savePoundInfoAResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->web__savePoundInfoAResponse::return_);
#endif
}

int web__savePoundInfoAResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_web__savePoundInfoAResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_web__savePoundInfoAResponse(struct soap *soap, const char *tag, int id, const web__savePoundInfoAResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_web__savePoundInfoAResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "return", -1, &a->web__savePoundInfoAResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *web__savePoundInfoAResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_web__savePoundInfoAResponse(soap, tag, this, type);
}

SOAP_FMAC3 web__savePoundInfoAResponse * SOAP_FMAC4 soap_in_web__savePoundInfoAResponse(struct soap *soap, const char *tag, web__savePoundInfoAResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (web__savePoundInfoAResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_web__savePoundInfoAResponse, sizeof(web__savePoundInfoAResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_web__savePoundInfoAResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (web__savePoundInfoAResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_return_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "return", &a->web__savePoundInfoAResponse::return_, "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (web__savePoundInfoAResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_web__savePoundInfoAResponse, SOAP_TYPE_web__savePoundInfoAResponse, sizeof(web__savePoundInfoAResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 web__savePoundInfoAResponse * SOAP_FMAC2 soap_instantiate_web__savePoundInfoAResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_web__savePoundInfoAResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	web__savePoundInfoAResponse *p;
	size_t k = sizeof(web__savePoundInfoAResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_web__savePoundInfoAResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, web__savePoundInfoAResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, web__savePoundInfoAResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated web__savePoundInfoAResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int web__savePoundInfoAResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_web__savePoundInfoAResponse(soap, tag ? tag : "web:savePoundInfoAResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *web__savePoundInfoAResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_web__savePoundInfoAResponse(soap, this, tag, type);
}

SOAP_FMAC3 web__savePoundInfoAResponse * SOAP_FMAC4 soap_get_web__savePoundInfoAResponse(struct soap *soap, web__savePoundInfoAResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_web__savePoundInfoAResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void web__savePoundInfoA::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->web__savePoundInfoA::arg0 = NULL;
	this->web__savePoundInfoA::arg1 = NULL;
	this->web__savePoundInfoA::arg2 = NULL;
	this->web__savePoundInfoA::arg3 = NULL;
	this->web__savePoundInfoA::arg4 = NULL;
	this->web__savePoundInfoA::arg5 = NULL;
	this->web__savePoundInfoA::arg6 = NULL;
	this->web__savePoundInfoA::arg7 = NULL;
	this->web__savePoundInfoA::arg8 = NULL;
	this->web__savePoundInfoA::arg9 = NULL;
	this->web__savePoundInfoA::arg10 = NULL;
	this->web__savePoundInfoA::arg11 = NULL;
	this->web__savePoundInfoA::arg12 = NULL;
	this->web__savePoundInfoA::arg13 = NULL;
	this->web__savePoundInfoA::arg14 = NULL;
	/* transient soap skipped */
}

void web__savePoundInfoA::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->web__savePoundInfoA::arg0);
	soap_serialize_PointerTostd__string(soap, &this->web__savePoundInfoA::arg1);
	soap_serialize_PointerTostd__string(soap, &this->web__savePoundInfoA::arg2);
	soap_serialize_PointerTostd__string(soap, &this->web__savePoundInfoA::arg3);
	soap_serialize_PointerTostd__string(soap, &this->web__savePoundInfoA::arg4);
	soap_serialize_PointerTostd__string(soap, &this->web__savePoundInfoA::arg5);
	soap_serialize_PointerTostd__string(soap, &this->web__savePoundInfoA::arg6);
	soap_serialize_PointerTostd__string(soap, &this->web__savePoundInfoA::arg7);
	soap_serialize_PointerTostd__string(soap, &this->web__savePoundInfoA::arg8);
	soap_serialize_PointerTostd__string(soap, &this->web__savePoundInfoA::arg9);
	soap_serialize_PointerTostd__string(soap, &this->web__savePoundInfoA::arg10);
	soap_serialize_PointerTostd__string(soap, &this->web__savePoundInfoA::arg11);
	soap_serialize_PointerTostd__string(soap, &this->web__savePoundInfoA::arg12);
	soap_serialize_PointerTostd__string(soap, &this->web__savePoundInfoA::arg13);
	soap_serialize_PointerTostd__string(soap, &this->web__savePoundInfoA::arg14);
#endif
}

int web__savePoundInfoA::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_web__savePoundInfoA(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_web__savePoundInfoA(struct soap *soap, const char *tag, int id, const web__savePoundInfoA *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_web__savePoundInfoA), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &a->web__savePoundInfoA::arg0, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg1", -1, &a->web__savePoundInfoA::arg1, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg2", -1, &a->web__savePoundInfoA::arg2, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg3", -1, &a->web__savePoundInfoA::arg3, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg4", -1, &a->web__savePoundInfoA::arg4, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg5", -1, &a->web__savePoundInfoA::arg5, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg6", -1, &a->web__savePoundInfoA::arg6, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg7", -1, &a->web__savePoundInfoA::arg7, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg8", -1, &a->web__savePoundInfoA::arg8, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg9", -1, &a->web__savePoundInfoA::arg9, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg10", -1, &a->web__savePoundInfoA::arg10, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg11", -1, &a->web__savePoundInfoA::arg11, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg12", -1, &a->web__savePoundInfoA::arg12, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg13", -1, &a->web__savePoundInfoA::arg13, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg14", -1, &a->web__savePoundInfoA::arg14, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *web__savePoundInfoA::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_web__savePoundInfoA(soap, tag, this, type);
}

SOAP_FMAC3 web__savePoundInfoA * SOAP_FMAC4 soap_in_web__savePoundInfoA(struct soap *soap, const char *tag, web__savePoundInfoA *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (web__savePoundInfoA *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_web__savePoundInfoA, sizeof(web__savePoundInfoA), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_web__savePoundInfoA)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (web__savePoundInfoA *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_arg11 = 1;
	size_t soap_flag_arg21 = 1;
	size_t soap_flag_arg31 = 1;
	size_t soap_flag_arg41 = 1;
	size_t soap_flag_arg51 = 1;
	size_t soap_flag_arg61 = 1;
	size_t soap_flag_arg71 = 1;
	size_t soap_flag_arg81 = 1;
	size_t soap_flag_arg91 = 1;
	size_t soap_flag_arg101 = 1;
	size_t soap_flag_arg111 = 1;
	size_t soap_flag_arg121 = 1;
	size_t soap_flag_arg131 = 1;
	size_t soap_flag_arg141 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg0", &a->web__savePoundInfoA::arg0, "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap_flag_arg11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg1", &a->web__savePoundInfoA::arg1, "xsd:string"))
				{	soap_flag_arg11--;
					continue;
				}
			}
			if (soap_flag_arg21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg2", &a->web__savePoundInfoA::arg2, "xsd:string"))
				{	soap_flag_arg21--;
					continue;
				}
			}
			if (soap_flag_arg31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg3", &a->web__savePoundInfoA::arg3, "xsd:string"))
				{	soap_flag_arg31--;
					continue;
				}
			}
			if (soap_flag_arg41 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg4", &a->web__savePoundInfoA::arg4, "xsd:string"))
				{	soap_flag_arg41--;
					continue;
				}
			}
			if (soap_flag_arg51 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg5", &a->web__savePoundInfoA::arg5, "xsd:string"))
				{	soap_flag_arg51--;
					continue;
				}
			}
			if (soap_flag_arg61 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg6", &a->web__savePoundInfoA::arg6, "xsd:string"))
				{	soap_flag_arg61--;
					continue;
				}
			}
			if (soap_flag_arg71 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg7", &a->web__savePoundInfoA::arg7, "xsd:string"))
				{	soap_flag_arg71--;
					continue;
				}
			}
			if (soap_flag_arg81 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg8", &a->web__savePoundInfoA::arg8, "xsd:string"))
				{	soap_flag_arg81--;
					continue;
				}
			}
			if (soap_flag_arg91 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg9", &a->web__savePoundInfoA::arg9, "xsd:string"))
				{	soap_flag_arg91--;
					continue;
				}
			}
			if (soap_flag_arg101 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg10", &a->web__savePoundInfoA::arg10, "xsd:string"))
				{	soap_flag_arg101--;
					continue;
				}
			}
			if (soap_flag_arg111 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg11", &a->web__savePoundInfoA::arg11, "xsd:string"))
				{	soap_flag_arg111--;
					continue;
				}
			}
			if (soap_flag_arg121 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg12", &a->web__savePoundInfoA::arg12, "xsd:string"))
				{	soap_flag_arg121--;
					continue;
				}
			}
			if (soap_flag_arg131 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg13", &a->web__savePoundInfoA::arg13, "xsd:string"))
				{	soap_flag_arg131--;
					continue;
				}
			}
			if (soap_flag_arg141 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg14", &a->web__savePoundInfoA::arg14, "xsd:string"))
				{	soap_flag_arg141--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (web__savePoundInfoA *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_web__savePoundInfoA, SOAP_TYPE_web__savePoundInfoA, sizeof(web__savePoundInfoA), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 web__savePoundInfoA * SOAP_FMAC2 soap_instantiate_web__savePoundInfoA(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_web__savePoundInfoA(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	web__savePoundInfoA *p;
	size_t k = sizeof(web__savePoundInfoA);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_web__savePoundInfoA, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, web__savePoundInfoA);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, web__savePoundInfoA, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated web__savePoundInfoA location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int web__savePoundInfoA::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_web__savePoundInfoA(soap, tag ? tag : "web:savePoundInfoA", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *web__savePoundInfoA::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_web__savePoundInfoA(soap, this, tag, type);
}

SOAP_FMAC3 web__savePoundInfoA * SOAP_FMAC4 soap_get_web__savePoundInfoA(struct soap *soap, web__savePoundInfoA *p, const char *tag, const char *type)
{
	if ((p = soap_in_web__savePoundInfoA(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void web__updatePasswordResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->web__updatePasswordResponse::return_ = NULL;
	/* transient soap skipped */
}

void web__updatePasswordResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->web__updatePasswordResponse::return_);
#endif
}

int web__updatePasswordResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_web__updatePasswordResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_web__updatePasswordResponse(struct soap *soap, const char *tag, int id, const web__updatePasswordResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_web__updatePasswordResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "return", -1, &a->web__updatePasswordResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *web__updatePasswordResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_web__updatePasswordResponse(soap, tag, this, type);
}

SOAP_FMAC3 web__updatePasswordResponse * SOAP_FMAC4 soap_in_web__updatePasswordResponse(struct soap *soap, const char *tag, web__updatePasswordResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (web__updatePasswordResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_web__updatePasswordResponse, sizeof(web__updatePasswordResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_web__updatePasswordResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (web__updatePasswordResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_return_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "return", &a->web__updatePasswordResponse::return_, "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (web__updatePasswordResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_web__updatePasswordResponse, SOAP_TYPE_web__updatePasswordResponse, sizeof(web__updatePasswordResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 web__updatePasswordResponse * SOAP_FMAC2 soap_instantiate_web__updatePasswordResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_web__updatePasswordResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	web__updatePasswordResponse *p;
	size_t k = sizeof(web__updatePasswordResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_web__updatePasswordResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, web__updatePasswordResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, web__updatePasswordResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated web__updatePasswordResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int web__updatePasswordResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_web__updatePasswordResponse(soap, tag ? tag : "web:updatePasswordResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *web__updatePasswordResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_web__updatePasswordResponse(soap, this, tag, type);
}

SOAP_FMAC3 web__updatePasswordResponse * SOAP_FMAC4 soap_get_web__updatePasswordResponse(struct soap *soap, web__updatePasswordResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_web__updatePasswordResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void web__updatePassword::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->web__updatePassword::arg0 = NULL;
	this->web__updatePassword::arg1 = NULL;
	this->web__updatePassword::arg2 = NULL;
	/* transient soap skipped */
}

void web__updatePassword::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->web__updatePassword::arg0);
	soap_serialize_PointerTostd__string(soap, &this->web__updatePassword::arg1);
	soap_serialize_PointerTostd__string(soap, &this->web__updatePassword::arg2);
#endif
}

int web__updatePassword::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_web__updatePassword(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_web__updatePassword(struct soap *soap, const char *tag, int id, const web__updatePassword *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_web__updatePassword), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &a->web__updatePassword::arg0, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg1", -1, &a->web__updatePassword::arg1, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg2", -1, &a->web__updatePassword::arg2, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *web__updatePassword::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_web__updatePassword(soap, tag, this, type);
}

SOAP_FMAC3 web__updatePassword * SOAP_FMAC4 soap_in_web__updatePassword(struct soap *soap, const char *tag, web__updatePassword *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (web__updatePassword *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_web__updatePassword, sizeof(web__updatePassword), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_web__updatePassword)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (web__updatePassword *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_arg11 = 1;
	size_t soap_flag_arg21 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg0", &a->web__updatePassword::arg0, "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap_flag_arg11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg1", &a->web__updatePassword::arg1, "xsd:string"))
				{	soap_flag_arg11--;
					continue;
				}
			}
			if (soap_flag_arg21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg2", &a->web__updatePassword::arg2, "xsd:string"))
				{	soap_flag_arg21--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (web__updatePassword *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_web__updatePassword, SOAP_TYPE_web__updatePassword, sizeof(web__updatePassword), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 web__updatePassword * SOAP_FMAC2 soap_instantiate_web__updatePassword(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_web__updatePassword(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	web__updatePassword *p;
	size_t k = sizeof(web__updatePassword);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_web__updatePassword, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, web__updatePassword);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, web__updatePassword, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated web__updatePassword location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int web__updatePassword::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_web__updatePassword(soap, tag ? tag : "web:updatePassword", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *web__updatePassword::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_web__updatePassword(soap, this, tag, type);
}

SOAP_FMAC3 web__updatePassword * SOAP_FMAC4 soap_get_web__updatePassword(struct soap *soap, web__updatePassword *p, const char *tag, const char *type)
{
	if ((p = soap_in_web__updatePassword(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void web__saveSamplersResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->web__saveSamplersResponse::return_ = NULL;
	/* transient soap skipped */
}

void web__saveSamplersResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->web__saveSamplersResponse::return_);
#endif
}

int web__saveSamplersResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_web__saveSamplersResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_web__saveSamplersResponse(struct soap *soap, const char *tag, int id, const web__saveSamplersResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_web__saveSamplersResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "return", -1, &a->web__saveSamplersResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *web__saveSamplersResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_web__saveSamplersResponse(soap, tag, this, type);
}

SOAP_FMAC3 web__saveSamplersResponse * SOAP_FMAC4 soap_in_web__saveSamplersResponse(struct soap *soap, const char *tag, web__saveSamplersResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (web__saveSamplersResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_web__saveSamplersResponse, sizeof(web__saveSamplersResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_web__saveSamplersResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (web__saveSamplersResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_return_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "return", &a->web__saveSamplersResponse::return_, "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (web__saveSamplersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_web__saveSamplersResponse, SOAP_TYPE_web__saveSamplersResponse, sizeof(web__saveSamplersResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 web__saveSamplersResponse * SOAP_FMAC2 soap_instantiate_web__saveSamplersResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_web__saveSamplersResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	web__saveSamplersResponse *p;
	size_t k = sizeof(web__saveSamplersResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_web__saveSamplersResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, web__saveSamplersResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, web__saveSamplersResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated web__saveSamplersResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int web__saveSamplersResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_web__saveSamplersResponse(soap, tag ? tag : "web:saveSamplersResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *web__saveSamplersResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_web__saveSamplersResponse(soap, this, tag, type);
}

SOAP_FMAC3 web__saveSamplersResponse * SOAP_FMAC4 soap_get_web__saveSamplersResponse(struct soap *soap, web__saveSamplersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_web__saveSamplersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void web__saveSamplers::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->web__saveSamplers::arg0 = NULL;
	this->web__saveSamplers::arg1 = NULL;
	this->web__saveSamplers::arg2 = NULL;
	this->web__saveSamplers::arg3 = NULL;
	this->web__saveSamplers::arg4 = NULL;
	this->web__saveSamplers::arg5 = NULL;
	this->web__saveSamplers::arg6 = NULL;
	this->web__saveSamplers::arg7 = NULL;
	this->web__saveSamplers::arg8 = NULL;
	this->web__saveSamplers::arg9 = NULL;
	this->web__saveSamplers::arg10 = NULL;
	this->web__saveSamplers::arg11 = NULL;
	/* transient soap skipped */
}

void web__saveSamplers::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->web__saveSamplers::arg0);
	soap_serialize_PointerTostd__string(soap, &this->web__saveSamplers::arg1);
	soap_serialize_PointerTostd__string(soap, &this->web__saveSamplers::arg2);
	soap_serialize_PointerTostd__string(soap, &this->web__saveSamplers::arg3);
	soap_serialize_PointerTostd__string(soap, &this->web__saveSamplers::arg4);
	soap_serialize_PointerTostd__string(soap, &this->web__saveSamplers::arg5);
	soap_serialize_PointerTostd__string(soap, &this->web__saveSamplers::arg6);
	soap_serialize_PointerTostd__string(soap, &this->web__saveSamplers::arg7);
	soap_serialize_PointerTostd__string(soap, &this->web__saveSamplers::arg8);
	soap_serialize_PointerTostd__string(soap, &this->web__saveSamplers::arg9);
	soap_serialize_PointerTostd__string(soap, &this->web__saveSamplers::arg10);
	soap_serialize_PointerTostd__string(soap, &this->web__saveSamplers::arg11);
#endif
}

int web__saveSamplers::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_web__saveSamplers(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_web__saveSamplers(struct soap *soap, const char *tag, int id, const web__saveSamplers *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_web__saveSamplers), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &a->web__saveSamplers::arg0, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg1", -1, &a->web__saveSamplers::arg1, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg2", -1, &a->web__saveSamplers::arg2, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg3", -1, &a->web__saveSamplers::arg3, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg4", -1, &a->web__saveSamplers::arg4, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg5", -1, &a->web__saveSamplers::arg5, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg6", -1, &a->web__saveSamplers::arg6, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg7", -1, &a->web__saveSamplers::arg7, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg8", -1, &a->web__saveSamplers::arg8, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg9", -1, &a->web__saveSamplers::arg9, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg10", -1, &a->web__saveSamplers::arg10, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg11", -1, &a->web__saveSamplers::arg11, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *web__saveSamplers::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_web__saveSamplers(soap, tag, this, type);
}

SOAP_FMAC3 web__saveSamplers * SOAP_FMAC4 soap_in_web__saveSamplers(struct soap *soap, const char *tag, web__saveSamplers *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (web__saveSamplers *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_web__saveSamplers, sizeof(web__saveSamplers), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_web__saveSamplers)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (web__saveSamplers *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_arg11 = 1;
	size_t soap_flag_arg21 = 1;
	size_t soap_flag_arg31 = 1;
	size_t soap_flag_arg41 = 1;
	size_t soap_flag_arg51 = 1;
	size_t soap_flag_arg61 = 1;
	size_t soap_flag_arg71 = 1;
	size_t soap_flag_arg81 = 1;
	size_t soap_flag_arg91 = 1;
	size_t soap_flag_arg101 = 1;
	size_t soap_flag_arg111 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg0", &a->web__saveSamplers::arg0, "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap_flag_arg11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg1", &a->web__saveSamplers::arg1, "xsd:string"))
				{	soap_flag_arg11--;
					continue;
				}
			}
			if (soap_flag_arg21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg2", &a->web__saveSamplers::arg2, "xsd:string"))
				{	soap_flag_arg21--;
					continue;
				}
			}
			if (soap_flag_arg31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg3", &a->web__saveSamplers::arg3, "xsd:string"))
				{	soap_flag_arg31--;
					continue;
				}
			}
			if (soap_flag_arg41 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg4", &a->web__saveSamplers::arg4, "xsd:string"))
				{	soap_flag_arg41--;
					continue;
				}
			}
			if (soap_flag_arg51 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg5", &a->web__saveSamplers::arg5, "xsd:string"))
				{	soap_flag_arg51--;
					continue;
				}
			}
			if (soap_flag_arg61 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg6", &a->web__saveSamplers::arg6, "xsd:string"))
				{	soap_flag_arg61--;
					continue;
				}
			}
			if (soap_flag_arg71 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg7", &a->web__saveSamplers::arg7, "xsd:string"))
				{	soap_flag_arg71--;
					continue;
				}
			}
			if (soap_flag_arg81 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg8", &a->web__saveSamplers::arg8, "xsd:string"))
				{	soap_flag_arg81--;
					continue;
				}
			}
			if (soap_flag_arg91 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg9", &a->web__saveSamplers::arg9, "xsd:string"))
				{	soap_flag_arg91--;
					continue;
				}
			}
			if (soap_flag_arg101 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg10", &a->web__saveSamplers::arg10, "xsd:string"))
				{	soap_flag_arg101--;
					continue;
				}
			}
			if (soap_flag_arg111 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg11", &a->web__saveSamplers::arg11, "xsd:string"))
				{	soap_flag_arg111--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (web__saveSamplers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_web__saveSamplers, SOAP_TYPE_web__saveSamplers, sizeof(web__saveSamplers), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 web__saveSamplers * SOAP_FMAC2 soap_instantiate_web__saveSamplers(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_web__saveSamplers(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	web__saveSamplers *p;
	size_t k = sizeof(web__saveSamplers);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_web__saveSamplers, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, web__saveSamplers);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, web__saveSamplers, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated web__saveSamplers location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int web__saveSamplers::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_web__saveSamplers(soap, tag ? tag : "web:saveSamplers", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *web__saveSamplers::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_web__saveSamplers(soap, this, tag, type);
}

SOAP_FMAC3 web__saveSamplers * SOAP_FMAC4 soap_get_web__saveSamplers(struct soap *soap, web__saveSamplers *p, const char *tag, const char *type)
{
	if ((p = soap_in_web__saveSamplers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void web__saveGPOrdersResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->web__saveGPOrdersResponse::return_ = NULL;
	/* transient soap skipped */
}

void web__saveGPOrdersResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->web__saveGPOrdersResponse::return_);
#endif
}

int web__saveGPOrdersResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_web__saveGPOrdersResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_web__saveGPOrdersResponse(struct soap *soap, const char *tag, int id, const web__saveGPOrdersResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_web__saveGPOrdersResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "return", -1, &a->web__saveGPOrdersResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *web__saveGPOrdersResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_web__saveGPOrdersResponse(soap, tag, this, type);
}

SOAP_FMAC3 web__saveGPOrdersResponse * SOAP_FMAC4 soap_in_web__saveGPOrdersResponse(struct soap *soap, const char *tag, web__saveGPOrdersResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (web__saveGPOrdersResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_web__saveGPOrdersResponse, sizeof(web__saveGPOrdersResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_web__saveGPOrdersResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (web__saveGPOrdersResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_return_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "return", &a->web__saveGPOrdersResponse::return_, "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (web__saveGPOrdersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_web__saveGPOrdersResponse, SOAP_TYPE_web__saveGPOrdersResponse, sizeof(web__saveGPOrdersResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 web__saveGPOrdersResponse * SOAP_FMAC2 soap_instantiate_web__saveGPOrdersResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_web__saveGPOrdersResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	web__saveGPOrdersResponse *p;
	size_t k = sizeof(web__saveGPOrdersResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_web__saveGPOrdersResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, web__saveGPOrdersResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, web__saveGPOrdersResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated web__saveGPOrdersResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int web__saveGPOrdersResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_web__saveGPOrdersResponse(soap, tag ? tag : "web:saveGPOrdersResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *web__saveGPOrdersResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_web__saveGPOrdersResponse(soap, this, tag, type);
}

SOAP_FMAC3 web__saveGPOrdersResponse * SOAP_FMAC4 soap_get_web__saveGPOrdersResponse(struct soap *soap, web__saveGPOrdersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_web__saveGPOrdersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void web__gpOrders::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->web__gpOrders::ad_USCOREclient_USCOREid);
	soap_default_int(soap, &this->web__gpOrders::ad_USCOREorg_USCOREid);
	soap_default_int(soap, &this->web__gpOrders::ad_USCORErole_USCOREid);
	soap_default_int(soap, &this->web__gpOrders::ad_USCOREuser_USCOREid);
	this->web__gpOrders::address1 = NULL;
	soap_default_int(soap, &this->web__gpOrders::c_USCOREcontract_USCOREid);
	soap_default_int(soap, &this->web__gpOrders::c_USCOREdoctype_USCOREid);
	soap_default_int(soap, &this->web__gpOrders::c_USCOREdoctypetarget_USCOREid);
	soap_default_int(soap, &this->web__gpOrders::c_USCOREgporders_USCOREid);
	soap_default_int(soap, &this->web__gpOrders::c_USCOREgrainuser_USCOREid);
	soap_default_int(soap, &this->web__gpOrders::c_USCORElocation_USCOREid);
	soap_default_int(soap, &this->web__gpOrders::c_USCOREtargetvehicle_USCOREid);
	soap_default_int(soap, &this->web__gpOrders::c_USCOREvehicleinfo_USCOREid);
	soap_default_int(soap, &this->web__gpOrders::c_USCOREvendor_USCOREid);
	this->web__gpOrders::color = NULL;
	soap_default_int(soap, &this->web__gpOrders::currentelectricity);
	this->web__gpOrders::docaction = NULL;
	this->web__gpOrders::docstatus = NULL;
	this->web__gpOrders::documentno = NULL;
	this->web__gpOrders::idcard = NULL;
	this->web__gpOrders::idcardbutton = NULL;
	soap_default_bool(soap, &this->web__gpOrders::isapproved);
	soap_default_bool(soap, &this->web__gpOrders::isvendor);
	this->web__gpOrders::license = NULL;
	this->web__gpOrders::packingtype = NULL;
	soap_default_bool(soap, &this->web__gpOrders::processed);
	soap_default_bool(soap, &this->web__gpOrders::processing);
	this->web__gpOrders::recheckbutton = NULL;
	this->web__gpOrders::settlementcardbutton = NULL;
	this->web__gpOrders::settlementcardid = NULL;
	this->web__gpOrders::tagbutton = NULL;
	this->web__gpOrders::tid = NULL;
	this->web__gpOrders::type = NULL;
	this->web__gpOrders::vehicleImage = NULL;
	this->web__gpOrders::vehiclebutton = NULL;
	/* transient soap skipped */
}

void web__gpOrders::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->web__gpOrders::address1);
	soap_serialize_PointerTostd__string(soap, &this->web__gpOrders::color);
	soap_serialize_PointerTostd__string(soap, &this->web__gpOrders::docaction);
	soap_serialize_PointerTostd__string(soap, &this->web__gpOrders::docstatus);
	soap_serialize_PointerTostd__string(soap, &this->web__gpOrders::documentno);
	soap_serialize_PointerTostd__string(soap, &this->web__gpOrders::idcard);
	soap_serialize_PointerTostd__string(soap, &this->web__gpOrders::idcardbutton);
	soap_serialize_PointerTostd__string(soap, &this->web__gpOrders::license);
	soap_serialize_PointerTostd__string(soap, &this->web__gpOrders::packingtype);
	soap_serialize_PointerTostd__string(soap, &this->web__gpOrders::recheckbutton);
	soap_serialize_PointerTostd__string(soap, &this->web__gpOrders::settlementcardbutton);
	soap_serialize_PointerTostd__string(soap, &this->web__gpOrders::settlementcardid);
	soap_serialize_PointerTostd__string(soap, &this->web__gpOrders::tagbutton);
	soap_serialize_PointerTostd__string(soap, &this->web__gpOrders::tid);
	soap_serialize_PointerTostd__string(soap, &this->web__gpOrders::type);
	soap_serialize_PointerTostd__string(soap, &this->web__gpOrders::vehicleImage);
	soap_serialize_PointerTostd__string(soap, &this->web__gpOrders::vehiclebutton);
#endif
}

int web__gpOrders::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_web__gpOrders(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_web__gpOrders(struct soap *soap, const char *tag, int id, const web__gpOrders *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_web__gpOrders), type))
		return soap->error;
	if (soap_out_int(soap, "ad_client_id", -1, &a->web__gpOrders::ad_USCOREclient_USCOREid, ""))
		return soap->error;
	if (soap_out_int(soap, "ad_org_id", -1, &a->web__gpOrders::ad_USCOREorg_USCOREid, ""))
		return soap->error;
	if (soap_out_int(soap, "ad_role_id", -1, &a->web__gpOrders::ad_USCORErole_USCOREid, ""))
		return soap->error;
	if (soap_out_int(soap, "ad_user_id", -1, &a->web__gpOrders::ad_USCOREuser_USCOREid, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "address1", -1, &a->web__gpOrders::address1, ""))
		return soap->error;
	if (soap_out_int(soap, "c_contract_id", -1, &a->web__gpOrders::c_USCOREcontract_USCOREid, ""))
		return soap->error;
	if (soap_out_int(soap, "c_doctype_id", -1, &a->web__gpOrders::c_USCOREdoctype_USCOREid, ""))
		return soap->error;
	if (soap_out_int(soap, "c_doctypetarget_id", -1, &a->web__gpOrders::c_USCOREdoctypetarget_USCOREid, ""))
		return soap->error;
	if (soap_out_int(soap, "c_gporders_id", -1, &a->web__gpOrders::c_USCOREgporders_USCOREid, ""))
		return soap->error;
	if (soap_out_int(soap, "c_grainuser_id", -1, &a->web__gpOrders::c_USCOREgrainuser_USCOREid, ""))
		return soap->error;
	if (soap_out_int(soap, "c_location_id", -1, &a->web__gpOrders::c_USCORElocation_USCOREid, ""))
		return soap->error;
	if (soap_out_int(soap, "c_targetvehicle_id", -1, &a->web__gpOrders::c_USCOREtargetvehicle_USCOREid, ""))
		return soap->error;
	if (soap_out_int(soap, "c_vehicleinfo_id", -1, &a->web__gpOrders::c_USCOREvehicleinfo_USCOREid, ""))
		return soap->error;
	if (soap_out_int(soap, "c_vendor_id", -1, &a->web__gpOrders::c_USCOREvendor_USCOREid, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "color", -1, &a->web__gpOrders::color, ""))
		return soap->error;
	if (soap_out_int(soap, "currentelectricity", -1, &a->web__gpOrders::currentelectricity, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "docaction", -1, &a->web__gpOrders::docaction, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "docstatus", -1, &a->web__gpOrders::docstatus, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "documentno", -1, &a->web__gpOrders::documentno, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "idcard", -1, &a->web__gpOrders::idcard, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "idcardbutton", -1, &a->web__gpOrders::idcardbutton, ""))
		return soap->error;
	if (soap_out_bool(soap, "isapproved", -1, &a->web__gpOrders::isapproved, ""))
		return soap->error;
	if (soap_out_bool(soap, "isvendor", -1, &a->web__gpOrders::isvendor, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "license", -1, &a->web__gpOrders::license, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "packingtype", -1, &a->web__gpOrders::packingtype, ""))
		return soap->error;
	if (soap_out_bool(soap, "processed", -1, &a->web__gpOrders::processed, ""))
		return soap->error;
	if (soap_out_bool(soap, "processing", -1, &a->web__gpOrders::processing, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "recheckbutton", -1, &a->web__gpOrders::recheckbutton, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "settlementcardbutton", -1, &a->web__gpOrders::settlementcardbutton, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "settlementcardid", -1, &a->web__gpOrders::settlementcardid, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tagbutton", -1, &a->web__gpOrders::tagbutton, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tid", -1, &a->web__gpOrders::tid, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "type", -1, &a->web__gpOrders::type, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "vehicleImage", -1, &a->web__gpOrders::vehicleImage, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "vehiclebutton", -1, &a->web__gpOrders::vehiclebutton, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *web__gpOrders::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_web__gpOrders(soap, tag, this, type);
}

SOAP_FMAC3 web__gpOrders * SOAP_FMAC4 soap_in_web__gpOrders(struct soap *soap, const char *tag, web__gpOrders *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (web__gpOrders *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_web__gpOrders, sizeof(web__gpOrders), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_web__gpOrders)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (web__gpOrders *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ad_USCOREclient_USCOREid1 = 1;
	size_t soap_flag_ad_USCOREorg_USCOREid1 = 1;
	size_t soap_flag_ad_USCORErole_USCOREid1 = 1;
	size_t soap_flag_ad_USCOREuser_USCOREid1 = 1;
	size_t soap_flag_address11 = 1;
	size_t soap_flag_c_USCOREcontract_USCOREid1 = 1;
	size_t soap_flag_c_USCOREdoctype_USCOREid1 = 1;
	size_t soap_flag_c_USCOREdoctypetarget_USCOREid1 = 1;
	size_t soap_flag_c_USCOREgporders_USCOREid1 = 1;
	size_t soap_flag_c_USCOREgrainuser_USCOREid1 = 1;
	size_t soap_flag_c_USCORElocation_USCOREid1 = 1;
	size_t soap_flag_c_USCOREtargetvehicle_USCOREid1 = 1;
	size_t soap_flag_c_USCOREvehicleinfo_USCOREid1 = 1;
	size_t soap_flag_c_USCOREvendor_USCOREid1 = 1;
	size_t soap_flag_color1 = 1;
	size_t soap_flag_currentelectricity1 = 1;
	size_t soap_flag_docaction1 = 1;
	size_t soap_flag_docstatus1 = 1;
	size_t soap_flag_documentno1 = 1;
	size_t soap_flag_idcard1 = 1;
	size_t soap_flag_idcardbutton1 = 1;
	size_t soap_flag_isapproved1 = 1;
	size_t soap_flag_isvendor1 = 1;
	size_t soap_flag_license1 = 1;
	size_t soap_flag_packingtype1 = 1;
	size_t soap_flag_processed1 = 1;
	size_t soap_flag_processing1 = 1;
	size_t soap_flag_recheckbutton1 = 1;
	size_t soap_flag_settlementcardbutton1 = 1;
	size_t soap_flag_settlementcardid1 = 1;
	size_t soap_flag_tagbutton1 = 1;
	size_t soap_flag_tid1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_vehicleImage1 = 1;
	size_t soap_flag_vehiclebutton1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ad_USCOREclient_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ad_client_id", &a->web__gpOrders::ad_USCOREclient_USCOREid, "xsd:int"))
				{	soap_flag_ad_USCOREclient_USCOREid1--;
					continue;
				}
			}
			if (soap_flag_ad_USCOREorg_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ad_org_id", &a->web__gpOrders::ad_USCOREorg_USCOREid, "xsd:int"))
				{	soap_flag_ad_USCOREorg_USCOREid1--;
					continue;
				}
			}
			if (soap_flag_ad_USCORErole_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ad_role_id", &a->web__gpOrders::ad_USCORErole_USCOREid, "xsd:int"))
				{	soap_flag_ad_USCORErole_USCOREid1--;
					continue;
				}
			}
			if (soap_flag_ad_USCOREuser_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ad_user_id", &a->web__gpOrders::ad_USCOREuser_USCOREid, "xsd:int"))
				{	soap_flag_ad_USCOREuser_USCOREid1--;
					continue;
				}
			}
			if (soap_flag_address11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "address1", &a->web__gpOrders::address1, "xsd:string"))
				{	soap_flag_address11--;
					continue;
				}
			}
			if (soap_flag_c_USCOREcontract_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "c_contract_id", &a->web__gpOrders::c_USCOREcontract_USCOREid, "xsd:int"))
				{	soap_flag_c_USCOREcontract_USCOREid1--;
					continue;
				}
			}
			if (soap_flag_c_USCOREdoctype_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "c_doctype_id", &a->web__gpOrders::c_USCOREdoctype_USCOREid, "xsd:int"))
				{	soap_flag_c_USCOREdoctype_USCOREid1--;
					continue;
				}
			}
			if (soap_flag_c_USCOREdoctypetarget_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "c_doctypetarget_id", &a->web__gpOrders::c_USCOREdoctypetarget_USCOREid, "xsd:int"))
				{	soap_flag_c_USCOREdoctypetarget_USCOREid1--;
					continue;
				}
			}
			if (soap_flag_c_USCOREgporders_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "c_gporders_id", &a->web__gpOrders::c_USCOREgporders_USCOREid, "xsd:int"))
				{	soap_flag_c_USCOREgporders_USCOREid1--;
					continue;
				}
			}
			if (soap_flag_c_USCOREgrainuser_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "c_grainuser_id", &a->web__gpOrders::c_USCOREgrainuser_USCOREid, "xsd:int"))
				{	soap_flag_c_USCOREgrainuser_USCOREid1--;
					continue;
				}
			}
			if (soap_flag_c_USCORElocation_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "c_location_id", &a->web__gpOrders::c_USCORElocation_USCOREid, "xsd:int"))
				{	soap_flag_c_USCORElocation_USCOREid1--;
					continue;
				}
			}
			if (soap_flag_c_USCOREtargetvehicle_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "c_targetvehicle_id", &a->web__gpOrders::c_USCOREtargetvehicle_USCOREid, "xsd:int"))
				{	soap_flag_c_USCOREtargetvehicle_USCOREid1--;
					continue;
				}
			}
			if (soap_flag_c_USCOREvehicleinfo_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "c_vehicleinfo_id", &a->web__gpOrders::c_USCOREvehicleinfo_USCOREid, "xsd:int"))
				{	soap_flag_c_USCOREvehicleinfo_USCOREid1--;
					continue;
				}
			}
			if (soap_flag_c_USCOREvendor_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "c_vendor_id", &a->web__gpOrders::c_USCOREvendor_USCOREid, "xsd:int"))
				{	soap_flag_c_USCOREvendor_USCOREid1--;
					continue;
				}
			}
			if (soap_flag_color1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "color", &a->web__gpOrders::color, "xsd:string"))
				{	soap_flag_color1--;
					continue;
				}
			}
			if (soap_flag_currentelectricity1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "currentelectricity", &a->web__gpOrders::currentelectricity, "xsd:int"))
				{	soap_flag_currentelectricity1--;
					continue;
				}
			}
			if (soap_flag_docaction1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "docaction", &a->web__gpOrders::docaction, "xsd:string"))
				{	soap_flag_docaction1--;
					continue;
				}
			}
			if (soap_flag_docstatus1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "docstatus", &a->web__gpOrders::docstatus, "xsd:string"))
				{	soap_flag_docstatus1--;
					continue;
				}
			}
			if (soap_flag_documentno1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "documentno", &a->web__gpOrders::documentno, "xsd:string"))
				{	soap_flag_documentno1--;
					continue;
				}
			}
			if (soap_flag_idcard1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "idcard", &a->web__gpOrders::idcard, "xsd:string"))
				{	soap_flag_idcard1--;
					continue;
				}
			}
			if (soap_flag_idcardbutton1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "idcardbutton", &a->web__gpOrders::idcardbutton, "xsd:string"))
				{	soap_flag_idcardbutton1--;
					continue;
				}
			}
			if (soap_flag_isapproved1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "isapproved", &a->web__gpOrders::isapproved, "xsd:boolean"))
				{	soap_flag_isapproved1--;
					continue;
				}
			}
			if (soap_flag_isvendor1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "isvendor", &a->web__gpOrders::isvendor, "xsd:boolean"))
				{	soap_flag_isvendor1--;
					continue;
				}
			}
			if (soap_flag_license1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "license", &a->web__gpOrders::license, "xsd:string"))
				{	soap_flag_license1--;
					continue;
				}
			}
			if (soap_flag_packingtype1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "packingtype", &a->web__gpOrders::packingtype, "xsd:string"))
				{	soap_flag_packingtype1--;
					continue;
				}
			}
			if (soap_flag_processed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "processed", &a->web__gpOrders::processed, "xsd:boolean"))
				{	soap_flag_processed1--;
					continue;
				}
			}
			if (soap_flag_processing1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "processing", &a->web__gpOrders::processing, "xsd:boolean"))
				{	soap_flag_processing1--;
					continue;
				}
			}
			if (soap_flag_recheckbutton1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "recheckbutton", &a->web__gpOrders::recheckbutton, "xsd:string"))
				{	soap_flag_recheckbutton1--;
					continue;
				}
			}
			if (soap_flag_settlementcardbutton1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "settlementcardbutton", &a->web__gpOrders::settlementcardbutton, "xsd:string"))
				{	soap_flag_settlementcardbutton1--;
					continue;
				}
			}
			if (soap_flag_settlementcardid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "settlementcardid", &a->web__gpOrders::settlementcardid, "xsd:string"))
				{	soap_flag_settlementcardid1--;
					continue;
				}
			}
			if (soap_flag_tagbutton1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tagbutton", &a->web__gpOrders::tagbutton, "xsd:string"))
				{	soap_flag_tagbutton1--;
					continue;
				}
			}
			if (soap_flag_tid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tid", &a->web__gpOrders::tid, "xsd:string"))
				{	soap_flag_tid1--;
					continue;
				}
			}
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "type", &a->web__gpOrders::type, "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			}
			if (soap_flag_vehicleImage1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "vehicleImage", &a->web__gpOrders::vehicleImage, "xsd:string"))
				{	soap_flag_vehicleImage1--;
					continue;
				}
			}
			if (soap_flag_vehiclebutton1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "vehiclebutton", &a->web__gpOrders::vehiclebutton, "xsd:string"))
				{	soap_flag_vehiclebutton1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ad_USCOREclient_USCOREid1 > 0 || soap_flag_ad_USCOREorg_USCOREid1 > 0 || soap_flag_ad_USCORErole_USCOREid1 > 0 || soap_flag_ad_USCOREuser_USCOREid1 > 0 || soap_flag_c_USCOREcontract_USCOREid1 > 0 || soap_flag_c_USCOREdoctype_USCOREid1 > 0 || soap_flag_c_USCOREdoctypetarget_USCOREid1 > 0 || soap_flag_c_USCOREgporders_USCOREid1 > 0 || soap_flag_c_USCOREgrainuser_USCOREid1 > 0 || soap_flag_c_USCORElocation_USCOREid1 > 0 || soap_flag_c_USCOREtargetvehicle_USCOREid1 > 0 || soap_flag_c_USCOREvehicleinfo_USCOREid1 > 0 || soap_flag_c_USCOREvendor_USCOREid1 > 0 || soap_flag_currentelectricity1 > 0 || soap_flag_isapproved1 > 0 || soap_flag_isvendor1 > 0 || soap_flag_processed1 > 0 || soap_flag_processing1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (web__gpOrders *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_web__gpOrders, SOAP_TYPE_web__gpOrders, sizeof(web__gpOrders), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 web__gpOrders * SOAP_FMAC2 soap_instantiate_web__gpOrders(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_web__gpOrders(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	web__gpOrders *p;
	size_t k = sizeof(web__gpOrders);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_web__gpOrders, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, web__gpOrders);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, web__gpOrders, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated web__gpOrders location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int web__gpOrders::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_web__gpOrders(soap, tag ? tag : "web:gpOrders", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *web__gpOrders::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_web__gpOrders(soap, this, tag, type);
}

SOAP_FMAC3 web__gpOrders * SOAP_FMAC4 soap_get_web__gpOrders(struct soap *soap, web__gpOrders *p, const char *tag, const char *type)
{
	if ((p = soap_in_web__gpOrders(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void web__saveGPOrders::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->web__saveGPOrders::arg0 = NULL;
	/* transient soap skipped */
}

void web__saveGPOrders::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToweb__gpOrders(soap, &this->web__saveGPOrders::arg0);
#endif
}

int web__saveGPOrders::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_web__saveGPOrders(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_web__saveGPOrders(struct soap *soap, const char *tag, int id, const web__saveGPOrders *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_web__saveGPOrders), type))
		return soap->error;
	if (soap_out_PointerToweb__gpOrders(soap, "arg0", -1, &a->web__saveGPOrders::arg0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *web__saveGPOrders::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_web__saveGPOrders(soap, tag, this, type);
}

SOAP_FMAC3 web__saveGPOrders * SOAP_FMAC4 soap_in_web__saveGPOrders(struct soap *soap, const char *tag, web__saveGPOrders *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (web__saveGPOrders *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_web__saveGPOrders, sizeof(web__saveGPOrders), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_web__saveGPOrders)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (web__saveGPOrders *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToweb__gpOrders(soap, "arg0", &a->web__saveGPOrders::arg0, "web:gpOrders"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (web__saveGPOrders *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_web__saveGPOrders, SOAP_TYPE_web__saveGPOrders, sizeof(web__saveGPOrders), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 web__saveGPOrders * SOAP_FMAC2 soap_instantiate_web__saveGPOrders(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_web__saveGPOrders(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	web__saveGPOrders *p;
	size_t k = sizeof(web__saveGPOrders);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_web__saveGPOrders, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, web__saveGPOrders);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, web__saveGPOrders, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated web__saveGPOrders location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int web__saveGPOrders::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_web__saveGPOrders(soap, tag ? tag : "web:saveGPOrders", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *web__saveGPOrders::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_web__saveGPOrders(soap, this, tag, type);
}

SOAP_FMAC3 web__saveGPOrders * SOAP_FMAC4 soap_get_web__saveGPOrders(struct soap *soap, web__saveGPOrders *p, const char *tag, const char *type)
{
	if ((p = soap_in_web__saveGPOrders(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->faultcode);
	soap_serialize_string(soap, (char*const*)&a->faultstring);
	soap_serialize_string(soap, (char*const*)&a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Node);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, (char*const*)&a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, (char*const*)&a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, (char*const*)&a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, (char*const*)&a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "faultcode", (char**)&a->faultcode, "xsd:QName"))
				{	soap_flag_faultcode--;
					continue;
				}
			}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultstring", (char**)&a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultactor", (char**)&a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Node", (char**)&a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Role", (char**)&a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Fault *p;
	size_t k = sizeof(struct SOAP_ENV__Fault);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Fault);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Fault, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Fault location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Fault(soap, tag ? tag : "SOAP-ENV:Fault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, (char*const*)&a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Text", (char**)&a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Reason *p;
	size_t k = sizeof(struct SOAP_ENV__Reason);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Reason);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Reason, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Reason location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Detail *p;
	size_t k = sizeof(struct SOAP_ENV__Detail);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Detail);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Detail, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Detail location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "SOAP-ENV:Value", (char**)&a->SOAP_ENV__Value, "xsd:QName"))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Code *p;
	size_t k = sizeof(struct SOAP_ENV__Code);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Code);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Code, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Code location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Header *p;
	size_t k = sizeof(struct SOAP_ENV__Header);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Header);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Header, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Header location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Header(soap, tag ? tag : "SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___web__login(struct soap *soap, struct __web__login *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->web__login_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___web__login(struct soap *soap, const struct __web__login *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToweb__login(soap, &a->web__login_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___web__login(struct soap *soap, const char *tag, int id, const struct __web__login *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerToweb__login(soap, "web:login", -1, &a->web__login_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __web__login * SOAP_FMAC4 soap_in___web__login(struct soap *soap, const char *tag, struct __web__login *a, const char *type)
{
	size_t soap_flag_web__login_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __web__login *)soap_id_enter(soap, "", a, SOAP_TYPE___web__login, sizeof(struct __web__login), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___web__login(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_web__login_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToweb__login(soap, "web:login", &a->web__login_, "web:login"))
				{	soap_flag_web__login_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __web__login * SOAP_FMAC2 soap_instantiate___web__login(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___web__login(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __web__login *p;
	size_t k = sizeof(struct __web__login);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___web__login, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __web__login);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __web__login, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __web__login location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___web__login(struct soap *soap, const struct __web__login *a, const char *tag, const char *type)
{
	if (soap_out___web__login(soap, tag ? tag : "-web:login", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __web__login * SOAP_FMAC4 soap_get___web__login(struct soap *soap, struct __web__login *p, const char *tag, const char *type)
{
	if ((p = soap_in___web__login(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___web__saveCheckingInfo(struct soap *soap, struct __web__saveCheckingInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->web__saveCheckingInfo_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___web__saveCheckingInfo(struct soap *soap, const struct __web__saveCheckingInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToweb__saveCheckingInfo(soap, &a->web__saveCheckingInfo_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___web__saveCheckingInfo(struct soap *soap, const char *tag, int id, const struct __web__saveCheckingInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerToweb__saveCheckingInfo(soap, "web:saveCheckingInfo", -1, &a->web__saveCheckingInfo_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __web__saveCheckingInfo * SOAP_FMAC4 soap_in___web__saveCheckingInfo(struct soap *soap, const char *tag, struct __web__saveCheckingInfo *a, const char *type)
{
	size_t soap_flag_web__saveCheckingInfo_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __web__saveCheckingInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___web__saveCheckingInfo, sizeof(struct __web__saveCheckingInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___web__saveCheckingInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_web__saveCheckingInfo_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToweb__saveCheckingInfo(soap, "web:saveCheckingInfo", &a->web__saveCheckingInfo_, "web:saveCheckingInfo"))
				{	soap_flag_web__saveCheckingInfo_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __web__saveCheckingInfo * SOAP_FMAC2 soap_instantiate___web__saveCheckingInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___web__saveCheckingInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __web__saveCheckingInfo *p;
	size_t k = sizeof(struct __web__saveCheckingInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___web__saveCheckingInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __web__saveCheckingInfo);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __web__saveCheckingInfo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __web__saveCheckingInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___web__saveCheckingInfo(struct soap *soap, const struct __web__saveCheckingInfo *a, const char *tag, const char *type)
{
	if (soap_out___web__saveCheckingInfo(soap, tag ? tag : "-web:saveCheckingInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __web__saveCheckingInfo * SOAP_FMAC4 soap_get___web__saveCheckingInfo(struct soap *soap, struct __web__saveCheckingInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___web__saveCheckingInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___web__saveSamplers(struct soap *soap, struct __web__saveSamplers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->web__saveSamplers_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___web__saveSamplers(struct soap *soap, const struct __web__saveSamplers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToweb__saveSamplers(soap, &a->web__saveSamplers_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___web__saveSamplers(struct soap *soap, const char *tag, int id, const struct __web__saveSamplers *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerToweb__saveSamplers(soap, "web:saveSamplers", -1, &a->web__saveSamplers_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __web__saveSamplers * SOAP_FMAC4 soap_in___web__saveSamplers(struct soap *soap, const char *tag, struct __web__saveSamplers *a, const char *type)
{
	size_t soap_flag_web__saveSamplers_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __web__saveSamplers *)soap_id_enter(soap, "", a, SOAP_TYPE___web__saveSamplers, sizeof(struct __web__saveSamplers), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___web__saveSamplers(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_web__saveSamplers_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToweb__saveSamplers(soap, "web:saveSamplers", &a->web__saveSamplers_, "web:saveSamplers"))
				{	soap_flag_web__saveSamplers_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __web__saveSamplers * SOAP_FMAC2 soap_instantiate___web__saveSamplers(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___web__saveSamplers(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __web__saveSamplers *p;
	size_t k = sizeof(struct __web__saveSamplers);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___web__saveSamplers, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __web__saveSamplers);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __web__saveSamplers, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __web__saveSamplers location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___web__saveSamplers(struct soap *soap, const struct __web__saveSamplers *a, const char *tag, const char *type)
{
	if (soap_out___web__saveSamplers(soap, tag ? tag : "-web:saveSamplers", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __web__saveSamplers * SOAP_FMAC4 soap_get___web__saveSamplers(struct soap *soap, struct __web__saveSamplers *p, const char *tag, const char *type)
{
	if ((p = soap_in___web__saveSamplers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___web__saveGPOrders(struct soap *soap, struct __web__saveGPOrders *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->web__saveGPOrders_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___web__saveGPOrders(struct soap *soap, const struct __web__saveGPOrders *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToweb__saveGPOrders(soap, &a->web__saveGPOrders_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___web__saveGPOrders(struct soap *soap, const char *tag, int id, const struct __web__saveGPOrders *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerToweb__saveGPOrders(soap, "web:saveGPOrders", -1, &a->web__saveGPOrders_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __web__saveGPOrders * SOAP_FMAC4 soap_in___web__saveGPOrders(struct soap *soap, const char *tag, struct __web__saveGPOrders *a, const char *type)
{
	size_t soap_flag_web__saveGPOrders_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __web__saveGPOrders *)soap_id_enter(soap, "", a, SOAP_TYPE___web__saveGPOrders, sizeof(struct __web__saveGPOrders), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___web__saveGPOrders(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_web__saveGPOrders_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToweb__saveGPOrders(soap, "web:saveGPOrders", &a->web__saveGPOrders_, "web:saveGPOrders"))
				{	soap_flag_web__saveGPOrders_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __web__saveGPOrders * SOAP_FMAC2 soap_instantiate___web__saveGPOrders(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___web__saveGPOrders(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __web__saveGPOrders *p;
	size_t k = sizeof(struct __web__saveGPOrders);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___web__saveGPOrders, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __web__saveGPOrders);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __web__saveGPOrders, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __web__saveGPOrders location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___web__saveGPOrders(struct soap *soap, const struct __web__saveGPOrders *a, const char *tag, const char *type)
{
	if (soap_out___web__saveGPOrders(soap, tag ? tag : "-web:saveGPOrders", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __web__saveGPOrders * SOAP_FMAC4 soap_get___web__saveGPOrders(struct soap *soap, struct __web__saveGPOrders *p, const char *tag, const char *type)
{
	if ((p = soap_in___web__saveGPOrders(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___web__savePoundInfo(struct soap *soap, struct __web__savePoundInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->web__savePoundInfo_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___web__savePoundInfo(struct soap *soap, const struct __web__savePoundInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToweb__savePoundInfo(soap, &a->web__savePoundInfo_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___web__savePoundInfo(struct soap *soap, const char *tag, int id, const struct __web__savePoundInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerToweb__savePoundInfo(soap, "web:savePoundInfo", -1, &a->web__savePoundInfo_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __web__savePoundInfo * SOAP_FMAC4 soap_in___web__savePoundInfo(struct soap *soap, const char *tag, struct __web__savePoundInfo *a, const char *type)
{
	size_t soap_flag_web__savePoundInfo_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __web__savePoundInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___web__savePoundInfo, sizeof(struct __web__savePoundInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___web__savePoundInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_web__savePoundInfo_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToweb__savePoundInfo(soap, "web:savePoundInfo", &a->web__savePoundInfo_, "web:savePoundInfo"))
				{	soap_flag_web__savePoundInfo_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __web__savePoundInfo * SOAP_FMAC2 soap_instantiate___web__savePoundInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___web__savePoundInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __web__savePoundInfo *p;
	size_t k = sizeof(struct __web__savePoundInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___web__savePoundInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __web__savePoundInfo);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __web__savePoundInfo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __web__savePoundInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___web__savePoundInfo(struct soap *soap, const struct __web__savePoundInfo *a, const char *tag, const char *type)
{
	if (soap_out___web__savePoundInfo(soap, tag ? tag : "-web:savePoundInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __web__savePoundInfo * SOAP_FMAC4 soap_get___web__savePoundInfo(struct soap *soap, struct __web__savePoundInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___web__savePoundInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___web__savePoundInfoA(struct soap *soap, struct __web__savePoundInfoA *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->web__savePoundInfoA_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___web__savePoundInfoA(struct soap *soap, const struct __web__savePoundInfoA *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToweb__savePoundInfoA(soap, &a->web__savePoundInfoA_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___web__savePoundInfoA(struct soap *soap, const char *tag, int id, const struct __web__savePoundInfoA *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerToweb__savePoundInfoA(soap, "web:savePoundInfoA", -1, &a->web__savePoundInfoA_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __web__savePoundInfoA * SOAP_FMAC4 soap_in___web__savePoundInfoA(struct soap *soap, const char *tag, struct __web__savePoundInfoA *a, const char *type)
{
	size_t soap_flag_web__savePoundInfoA_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __web__savePoundInfoA *)soap_id_enter(soap, "", a, SOAP_TYPE___web__savePoundInfoA, sizeof(struct __web__savePoundInfoA), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___web__savePoundInfoA(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_web__savePoundInfoA_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToweb__savePoundInfoA(soap, "web:savePoundInfoA", &a->web__savePoundInfoA_, "web:savePoundInfoA"))
				{	soap_flag_web__savePoundInfoA_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __web__savePoundInfoA * SOAP_FMAC2 soap_instantiate___web__savePoundInfoA(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___web__savePoundInfoA(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __web__savePoundInfoA *p;
	size_t k = sizeof(struct __web__savePoundInfoA);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___web__savePoundInfoA, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __web__savePoundInfoA);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __web__savePoundInfoA, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __web__savePoundInfoA location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___web__savePoundInfoA(struct soap *soap, const struct __web__savePoundInfoA *a, const char *tag, const char *type)
{
	if (soap_out___web__savePoundInfoA(soap, tag ? tag : "-web:savePoundInfoA", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __web__savePoundInfoA * SOAP_FMAC4 soap_get___web__savePoundInfoA(struct soap *soap, struct __web__savePoundInfoA *p, const char *tag, const char *type)
{
	if ((p = soap_in___web__savePoundInfoA(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___web__saveGrainUser(struct soap *soap, struct __web__saveGrainUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->web__saveGrainUser_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___web__saveGrainUser(struct soap *soap, const struct __web__saveGrainUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToweb__saveGrainUser(soap, &a->web__saveGrainUser_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___web__saveGrainUser(struct soap *soap, const char *tag, int id, const struct __web__saveGrainUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerToweb__saveGrainUser(soap, "web:saveGrainUser", -1, &a->web__saveGrainUser_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __web__saveGrainUser * SOAP_FMAC4 soap_in___web__saveGrainUser(struct soap *soap, const char *tag, struct __web__saveGrainUser *a, const char *type)
{
	size_t soap_flag_web__saveGrainUser_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __web__saveGrainUser *)soap_id_enter(soap, "", a, SOAP_TYPE___web__saveGrainUser, sizeof(struct __web__saveGrainUser), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___web__saveGrainUser(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_web__saveGrainUser_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToweb__saveGrainUser(soap, "web:saveGrainUser", &a->web__saveGrainUser_, "web:saveGrainUser"))
				{	soap_flag_web__saveGrainUser_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __web__saveGrainUser * SOAP_FMAC2 soap_instantiate___web__saveGrainUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___web__saveGrainUser(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __web__saveGrainUser *p;
	size_t k = sizeof(struct __web__saveGrainUser);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___web__saveGrainUser, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __web__saveGrainUser);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __web__saveGrainUser, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __web__saveGrainUser location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___web__saveGrainUser(struct soap *soap, const struct __web__saveGrainUser *a, const char *tag, const char *type)
{
	if (soap_out___web__saveGrainUser(soap, tag ? tag : "-web:saveGrainUser", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __web__saveGrainUser * SOAP_FMAC4 soap_get___web__saveGrainUser(struct soap *soap, struct __web__saveGrainUser *p, const char *tag, const char *type)
{
	if ((p = soap_in___web__saveGrainUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___web__saveVehicleInfo(struct soap *soap, struct __web__saveVehicleInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->web__saveVehicleInfo_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___web__saveVehicleInfo(struct soap *soap, const struct __web__saveVehicleInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToweb__saveVehicleInfo(soap, &a->web__saveVehicleInfo_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___web__saveVehicleInfo(struct soap *soap, const char *tag, int id, const struct __web__saveVehicleInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerToweb__saveVehicleInfo(soap, "web:saveVehicleInfo", -1, &a->web__saveVehicleInfo_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __web__saveVehicleInfo * SOAP_FMAC4 soap_in___web__saveVehicleInfo(struct soap *soap, const char *tag, struct __web__saveVehicleInfo *a, const char *type)
{
	size_t soap_flag_web__saveVehicleInfo_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __web__saveVehicleInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___web__saveVehicleInfo, sizeof(struct __web__saveVehicleInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___web__saveVehicleInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_web__saveVehicleInfo_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToweb__saveVehicleInfo(soap, "web:saveVehicleInfo", &a->web__saveVehicleInfo_, "web:saveVehicleInfo"))
				{	soap_flag_web__saveVehicleInfo_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __web__saveVehicleInfo * SOAP_FMAC2 soap_instantiate___web__saveVehicleInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___web__saveVehicleInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __web__saveVehicleInfo *p;
	size_t k = sizeof(struct __web__saveVehicleInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___web__saveVehicleInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __web__saveVehicleInfo);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __web__saveVehicleInfo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __web__saveVehicleInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___web__saveVehicleInfo(struct soap *soap, const struct __web__saveVehicleInfo *a, const char *tag, const char *type)
{
	if (soap_out___web__saveVehicleInfo(soap, tag ? tag : "-web:saveVehicleInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __web__saveVehicleInfo * SOAP_FMAC4 soap_get___web__saveVehicleInfo(struct soap *soap, struct __web__saveVehicleInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___web__saveVehicleInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___web__updatePassword(struct soap *soap, struct __web__updatePassword *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->web__updatePassword_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___web__updatePassword(struct soap *soap, const struct __web__updatePassword *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToweb__updatePassword(soap, &a->web__updatePassword_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___web__updatePassword(struct soap *soap, const char *tag, int id, const struct __web__updatePassword *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerToweb__updatePassword(soap, "web:updatePassword", -1, &a->web__updatePassword_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __web__updatePassword * SOAP_FMAC4 soap_in___web__updatePassword(struct soap *soap, const char *tag, struct __web__updatePassword *a, const char *type)
{
	size_t soap_flag_web__updatePassword_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __web__updatePassword *)soap_id_enter(soap, "", a, SOAP_TYPE___web__updatePassword, sizeof(struct __web__updatePassword), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___web__updatePassword(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_web__updatePassword_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToweb__updatePassword(soap, "web:updatePassword", &a->web__updatePassword_, "web:updatePassword"))
				{	soap_flag_web__updatePassword_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __web__updatePassword * SOAP_FMAC2 soap_instantiate___web__updatePassword(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___web__updatePassword(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __web__updatePassword *p;
	size_t k = sizeof(struct __web__updatePassword);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___web__updatePassword, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __web__updatePassword);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __web__updatePassword, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __web__updatePassword location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___web__updatePassword(struct soap *soap, const struct __web__updatePassword *a, const char *tag, const char *type)
{
	if (soap_out___web__updatePassword(soap, tag ? tag : "-web:updatePassword", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __web__updatePassword * SOAP_FMAC4 soap_get___web__updatePassword(struct soap *soap, struct __web__updatePassword *p, const char *tag, const char *type)
{
	if ((p = soap_in___web__updatePassword(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code, &mark);
	if (id < 0)
		return soap->error;
	(void)soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToweb__login(struct soap *soap, web__login *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_web__login))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToweb__login(struct soap *soap, const char *tag, int id, web__login *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_web__login, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_web__login ? type : NULL);
}

SOAP_FMAC3 web__login ** SOAP_FMAC4 soap_in_PointerToweb__login(struct soap *soap, const char *tag, web__login **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (web__login **)soap_malloc(soap, sizeof(web__login *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (web__login *)soap_instantiate_web__login(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (web__login **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_web__login, sizeof(web__login), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToweb__login(struct soap *soap, web__login *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToweb__login(soap, tag ? tag : "web:login", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 web__login ** SOAP_FMAC4 soap_get_PointerToweb__login(struct soap *soap, web__login **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToweb__login(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToweb__saveCheckingInfo(struct soap *soap, web__saveCheckingInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_web__saveCheckingInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToweb__saveCheckingInfo(struct soap *soap, const char *tag, int id, web__saveCheckingInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_web__saveCheckingInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_web__saveCheckingInfo ? type : NULL);
}

SOAP_FMAC3 web__saveCheckingInfo ** SOAP_FMAC4 soap_in_PointerToweb__saveCheckingInfo(struct soap *soap, const char *tag, web__saveCheckingInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (web__saveCheckingInfo **)soap_malloc(soap, sizeof(web__saveCheckingInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (web__saveCheckingInfo *)soap_instantiate_web__saveCheckingInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (web__saveCheckingInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_web__saveCheckingInfo, sizeof(web__saveCheckingInfo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToweb__saveCheckingInfo(struct soap *soap, web__saveCheckingInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToweb__saveCheckingInfo(soap, tag ? tag : "web:saveCheckingInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 web__saveCheckingInfo ** SOAP_FMAC4 soap_get_PointerToweb__saveCheckingInfo(struct soap *soap, web__saveCheckingInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToweb__saveCheckingInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToweb__saveSamplers(struct soap *soap, web__saveSamplers *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_web__saveSamplers))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToweb__saveSamplers(struct soap *soap, const char *tag, int id, web__saveSamplers *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_web__saveSamplers, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_web__saveSamplers ? type : NULL);
}

SOAP_FMAC3 web__saveSamplers ** SOAP_FMAC4 soap_in_PointerToweb__saveSamplers(struct soap *soap, const char *tag, web__saveSamplers **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (web__saveSamplers **)soap_malloc(soap, sizeof(web__saveSamplers *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (web__saveSamplers *)soap_instantiate_web__saveSamplers(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (web__saveSamplers **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_web__saveSamplers, sizeof(web__saveSamplers), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToweb__saveSamplers(struct soap *soap, web__saveSamplers *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToweb__saveSamplers(soap, tag ? tag : "web:saveSamplers", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 web__saveSamplers ** SOAP_FMAC4 soap_get_PointerToweb__saveSamplers(struct soap *soap, web__saveSamplers **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToweb__saveSamplers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToweb__saveGPOrders(struct soap *soap, web__saveGPOrders *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_web__saveGPOrders))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToweb__saveGPOrders(struct soap *soap, const char *tag, int id, web__saveGPOrders *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_web__saveGPOrders, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_web__saveGPOrders ? type : NULL);
}

SOAP_FMAC3 web__saveGPOrders ** SOAP_FMAC4 soap_in_PointerToweb__saveGPOrders(struct soap *soap, const char *tag, web__saveGPOrders **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (web__saveGPOrders **)soap_malloc(soap, sizeof(web__saveGPOrders *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (web__saveGPOrders *)soap_instantiate_web__saveGPOrders(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (web__saveGPOrders **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_web__saveGPOrders, sizeof(web__saveGPOrders), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToweb__saveGPOrders(struct soap *soap, web__saveGPOrders *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToweb__saveGPOrders(soap, tag ? tag : "web:saveGPOrders", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 web__saveGPOrders ** SOAP_FMAC4 soap_get_PointerToweb__saveGPOrders(struct soap *soap, web__saveGPOrders **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToweb__saveGPOrders(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToweb__savePoundInfo(struct soap *soap, web__savePoundInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_web__savePoundInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToweb__savePoundInfo(struct soap *soap, const char *tag, int id, web__savePoundInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_web__savePoundInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_web__savePoundInfo ? type : NULL);
}

SOAP_FMAC3 web__savePoundInfo ** SOAP_FMAC4 soap_in_PointerToweb__savePoundInfo(struct soap *soap, const char *tag, web__savePoundInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (web__savePoundInfo **)soap_malloc(soap, sizeof(web__savePoundInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (web__savePoundInfo *)soap_instantiate_web__savePoundInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (web__savePoundInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_web__savePoundInfo, sizeof(web__savePoundInfo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToweb__savePoundInfo(struct soap *soap, web__savePoundInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToweb__savePoundInfo(soap, tag ? tag : "web:savePoundInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 web__savePoundInfo ** SOAP_FMAC4 soap_get_PointerToweb__savePoundInfo(struct soap *soap, web__savePoundInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToweb__savePoundInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToweb__savePoundInfoA(struct soap *soap, web__savePoundInfoA *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_web__savePoundInfoA))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToweb__savePoundInfoA(struct soap *soap, const char *tag, int id, web__savePoundInfoA *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_web__savePoundInfoA, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_web__savePoundInfoA ? type : NULL);
}

SOAP_FMAC3 web__savePoundInfoA ** SOAP_FMAC4 soap_in_PointerToweb__savePoundInfoA(struct soap *soap, const char *tag, web__savePoundInfoA **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (web__savePoundInfoA **)soap_malloc(soap, sizeof(web__savePoundInfoA *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (web__savePoundInfoA *)soap_instantiate_web__savePoundInfoA(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (web__savePoundInfoA **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_web__savePoundInfoA, sizeof(web__savePoundInfoA), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToweb__savePoundInfoA(struct soap *soap, web__savePoundInfoA *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToweb__savePoundInfoA(soap, tag ? tag : "web:savePoundInfoA", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 web__savePoundInfoA ** SOAP_FMAC4 soap_get_PointerToweb__savePoundInfoA(struct soap *soap, web__savePoundInfoA **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToweb__savePoundInfoA(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToweb__saveGrainUser(struct soap *soap, web__saveGrainUser *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_web__saveGrainUser))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToweb__saveGrainUser(struct soap *soap, const char *tag, int id, web__saveGrainUser *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_web__saveGrainUser, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_web__saveGrainUser ? type : NULL);
}

SOAP_FMAC3 web__saveGrainUser ** SOAP_FMAC4 soap_in_PointerToweb__saveGrainUser(struct soap *soap, const char *tag, web__saveGrainUser **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (web__saveGrainUser **)soap_malloc(soap, sizeof(web__saveGrainUser *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (web__saveGrainUser *)soap_instantiate_web__saveGrainUser(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (web__saveGrainUser **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_web__saveGrainUser, sizeof(web__saveGrainUser), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToweb__saveGrainUser(struct soap *soap, web__saveGrainUser *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToweb__saveGrainUser(soap, tag ? tag : "web:saveGrainUser", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 web__saveGrainUser ** SOAP_FMAC4 soap_get_PointerToweb__saveGrainUser(struct soap *soap, web__saveGrainUser **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToweb__saveGrainUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToweb__saveVehicleInfo(struct soap *soap, web__saveVehicleInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_web__saveVehicleInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToweb__saveVehicleInfo(struct soap *soap, const char *tag, int id, web__saveVehicleInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_web__saveVehicleInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_web__saveVehicleInfo ? type : NULL);
}

SOAP_FMAC3 web__saveVehicleInfo ** SOAP_FMAC4 soap_in_PointerToweb__saveVehicleInfo(struct soap *soap, const char *tag, web__saveVehicleInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (web__saveVehicleInfo **)soap_malloc(soap, sizeof(web__saveVehicleInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (web__saveVehicleInfo *)soap_instantiate_web__saveVehicleInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (web__saveVehicleInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_web__saveVehicleInfo, sizeof(web__saveVehicleInfo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToweb__saveVehicleInfo(struct soap *soap, web__saveVehicleInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToweb__saveVehicleInfo(soap, tag ? tag : "web:saveVehicleInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 web__saveVehicleInfo ** SOAP_FMAC4 soap_get_PointerToweb__saveVehicleInfo(struct soap *soap, web__saveVehicleInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToweb__saveVehicleInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToweb__updatePassword(struct soap *soap, web__updatePassword *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_web__updatePassword))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToweb__updatePassword(struct soap *soap, const char *tag, int id, web__updatePassword *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_web__updatePassword, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_web__updatePassword ? type : NULL);
}

SOAP_FMAC3 web__updatePassword ** SOAP_FMAC4 soap_in_PointerToweb__updatePassword(struct soap *soap, const char *tag, web__updatePassword **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (web__updatePassword **)soap_malloc(soap, sizeof(web__updatePassword *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (web__updatePassword *)soap_instantiate_web__updatePassword(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (web__updatePassword **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_web__updatePassword, sizeof(web__updatePassword), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToweb__updatePassword(struct soap *soap, web__updatePassword *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToweb__updatePassword(soap, tag ? tag : "web:updatePassword", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 web__updatePassword ** SOAP_FMAC4 soap_get_PointerToweb__updatePassword(struct soap *soap, web__updatePassword **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToweb__updatePassword(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToweb__user(struct soap *soap, web__user *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_web__user))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToweb__user(struct soap *soap, const char *tag, int id, web__user *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_web__user, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_web__user ? type : NULL);
}

SOAP_FMAC3 web__user ** SOAP_FMAC4 soap_in_PointerToweb__user(struct soap *soap, const char *tag, web__user **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (web__user **)soap_malloc(soap, sizeof(web__user *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (web__user *)soap_instantiate_web__user(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (web__user **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_web__user, sizeof(web__user), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToweb__user(struct soap *soap, web__user *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToweb__user(soap, tag ? tag : "web:user", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 web__user ** SOAP_FMAC4 soap_get_PointerToweb__user(struct soap *soap, web__user **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToweb__user(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToweb__poundInfo(struct soap *soap, web__poundInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_web__poundInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToweb__poundInfo(struct soap *soap, const char *tag, int id, web__poundInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_web__poundInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_web__poundInfo ? type : NULL);
}

SOAP_FMAC3 web__poundInfo ** SOAP_FMAC4 soap_in_PointerToweb__poundInfo(struct soap *soap, const char *tag, web__poundInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (web__poundInfo **)soap_malloc(soap, sizeof(web__poundInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (web__poundInfo *)soap_instantiate_web__poundInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (web__poundInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_web__poundInfo, sizeof(web__poundInfo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToweb__poundInfo(struct soap *soap, web__poundInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToweb__poundInfo(soap, tag ? tag : "web:poundInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 web__poundInfo ** SOAP_FMAC4 soap_get_PointerToweb__poundInfo(struct soap *soap, web__poundInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToweb__poundInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToweb__checkingInfo(struct soap *soap, web__checkingInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_web__checkingInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToweb__checkingInfo(struct soap *soap, const char *tag, int id, web__checkingInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_web__checkingInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_web__checkingInfo ? type : NULL);
}

SOAP_FMAC3 web__checkingInfo ** SOAP_FMAC4 soap_in_PointerToweb__checkingInfo(struct soap *soap, const char *tag, web__checkingInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (web__checkingInfo **)soap_malloc(soap, sizeof(web__checkingInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (web__checkingInfo *)soap_instantiate_web__checkingInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (web__checkingInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_web__checkingInfo, sizeof(web__checkingInfo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToweb__checkingInfo(struct soap *soap, web__checkingInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToweb__checkingInfo(soap, tag ? tag : "web:checkingInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 web__checkingInfo ** SOAP_FMAC4 soap_get_PointerToweb__checkingInfo(struct soap *soap, web__checkingInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToweb__checkingInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTostd__string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToweb__gpOrders(struct soap *soap, web__gpOrders *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_web__gpOrders))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToweb__gpOrders(struct soap *soap, const char *tag, int id, web__gpOrders *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_web__gpOrders, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_web__gpOrders ? type : NULL);
}

SOAP_FMAC3 web__gpOrders ** SOAP_FMAC4 soap_in_PointerToweb__gpOrders(struct soap *soap, const char *tag, web__gpOrders **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (web__gpOrders **)soap_malloc(soap, sizeof(web__gpOrders *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (web__gpOrders *)soap_instantiate_web__gpOrders(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (web__gpOrders **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_web__gpOrders, sizeof(web__gpOrders), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToweb__gpOrders(struct soap *soap, web__gpOrders *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToweb__gpOrders(soap, tag ? tag : "web:gpOrders", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 web__gpOrders ** SOAP_FMAC4 soap_get_PointerToweb__gpOrders(struct soap *soap, web__gpOrders **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToweb__gpOrders(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__QName(soap, tag ? tag : "QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_new_string(struct soap *soap, int n)
{
	char * *a = static_cast<char * *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char *)));
	for (char * *p = a; p && n--; ++p)
		soap_default_string(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
